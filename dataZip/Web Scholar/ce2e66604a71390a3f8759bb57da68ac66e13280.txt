A LOCAL View of the Polynomial Hierarchy∗
Fabian Reiter /envel⌢pe
LIGM, Université Gustave Eiffel, Marne-la-Vallée, France
Abstract
We extend classical methods of computational complexity to the setting of distributed computing,
where they are sometimes more effective than in their original context. Our focus is on distributed
decision in the localmodel, where multiple networked computers communicate via synchronous
message-passing to collectively answer a question about their network topology. Rather unusually, we
impose two orthogonal constraints on the running time of this model: the number of communication
rounds is bounded by a constant, and the number of computation steps of each computer is
polynomially bounded by the size of its local input and the messages it receives.
By letting two players take turns assigning certificates to all computers in the network, we obtain
a generalization of the polynomial hierarchy (and hence of the complexity classes PandNP). We
then extend some key results of complexity theory to this setting, in particular the Cook–Levin
theorem (which identifies Boolean satisfiability as a complete problem for NP), and Fagin’s theorem
(which characterizes NPas the problems expressible in existential second-order logic). The original
results can be recovered as the special case where the network consists of a single computer. But
perhaps more surprisingly, the task of separating complexity classes becomes easier in the general
case: we can show that our hierarchy is infinite, while it remains notoriously open whether the same
is true in the case of a single computer. (By contrast, a collapse of our hierarchy would have implied
a collapse of the polynomial hierarchy.) As an application, we propose quantifier alternation as a
new approach to measuring the locality of problems in distributed computing.
2012 ACM Subject Classification Theory of computation →Distributed computing models; Theory
of computation→Complexity classes; Theory of computation →Problems, reductions and com-
pleteness; Theory of computation →Complexity theory and logic; Theory of computation →Finite
Model Theory
Keywords and phrases Distributed decision, LOCAL model, polynomial hierarchy, descriptive
complexity theory
Funding Partially supported by the ERC projects EQualIS (308087) and PaVeS(787367).
∗Typeset with the knowledge package: technical terms and symbols are hyperlinked to their definitions.arXiv:2305.09538v3  [cs.DC]  6 Nov 2023ii A LOCAL View of the Polynomial Hierarchy
Contents
1 Introduction 1
1.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.4 Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2 Informal overview 7
2.1 Our complexity classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2 Extending classical reductions . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.3 A logical characterization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.4 Infiniteness of our hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3 Preliminaries 15
4 Distributed Turing machines 17
5 Logic with bounded quantifiers 20
5.1 Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.2 Example formulas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
6 Restrictive arbiters 27
7 A generalization of Fagin’s theorem 29
8 Hardness and completeness results 38
9 Infiniteness of the local-polynomial hierarchy 46
9.1 Warming up at ground level . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
9.2 Climbing up the hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
9.2.1 A digression on pictures . . . . . . . . . . . . . . . . . . . . . . . . . . 50
9.2.2 From pictures to graphs . . . . . . . . . . . . . . . . . . . . . . . . . . 54
9.3 Completing the picture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
10 Discussion 65F. Reiter 1
1 Introduction
In this paper, we revisit classical computational complexity theory from the perspective of
distributed network computing. As we will see, certain standard notions and techniques
not only extend well to the distributed setting, but in some cases allow us to achieve more
there than in the centralized setting. We begin by setting the context, and then present our
approach and results.
1.1 Background
When solving a problem in a computer network using a distributed algorithm, a major
concern is the issue of locality. At its core lies the question of how much information each
computer needs to obtain about the rest of the network in order to solve the given problem.
The less information needed, the more local the problem.
The LOCAL model. In the late 1980s, Linial [ 27] introduced an influential model of
distributed computing that focuses entirely on locality, while abstracting away many other
issues such as failures, asynchrony, and bandwidth limitations. In this model, which Peleg [ 33]
later called the localmodel, a network consists of several computers that communicate
with their neighbors by exchanging messages through a sequence of fault-free synchronous
rounds. The computers, referred to as nodes, are all identical except for possessing globally
unique identifiers. They have unlimited computational power to process their local input
and the messages they receive in each round, and there is no limitation on the message sizes.
The goal in this setting is for the nodes to collectively solve some graph problem related
to the topology of their network. That is, the network serves both as the communication
infrastructure and as the input graph. Typically, the problem is a construction task such as
finding a (vertex or edge) coloring, a maximal matching, a maximal independent set, or a
spanning tree. After a finite number of rounds, each node should produce a local output
such as “my color is blue” or “I belong to the independent set”, and the combined output of
all nodes should yield a valid solution to the considered problem.
Since the localmodel imposes no constraints on computational power and message size,
once the nodes have communicated for a number of rounds greater than the diameter of the
network graph, they can in principle know the entire graph and thus solve any problem that
can be solved by a single computer in the centralized setting. Therefore, if we equate the
complexity of a problem with the number of rounds required to solve it, call this number
theround-time complexity , and measure it as a function of the number of nodes, then all
problems have a complexity that lies between constant round time (the purely local problems)
and linear round time (the inherently global problems). From this perspective, investigating
the locality of a problem amounts to determining its round-time complexity.
Constant round time. The role of constant round time in the localmodel is vaguely
analogous to the role of polynomial time in centralized computing, in that it provides a
first approximation of what constitutes an efficiently solvable problem. The rigorous study
of the class of problems solvable in constant round time was initiated in the early 1990s
by Naor and Stockmeyer [ 31]. To narrow down the area of investigation, they focused on
construction problems for which the validity of a proposed solution can at least be verified
in constant round time. For instance, a proposed vertex coloring can be easily verified in a
single round of communication (each node compares its own color with those of its neighbors),
whereas a proposed spanning tree cannot be verified locally (a sufficiently long cycle is2 A LOCAL View of the Polynomial Hierarchy
indistinguishable from a line). Given the analogy with centralized computing, construction
problems verifiable in constant round time are sometimes referred to as the distributed analog
of the complexity class FNP, i.e., the function problem variant of NP[37]. For technical
reasons, Naor and Stockmeyer considered only the subclass of locally verifiable problems for
which there are constant bounds on the maximum degree of the graphs and on the size of
the local inputs and outputs. This subclass, which they called LCL(forlocally checkable
labelings), became the foundation of a fruitful research program on locality in distributed
computing (see “Construction problems” at the end of Section 1.3).
Decision problems. Although research in distributed computing has traditionally focused
on construction problems, one of its newer branches, called distributed decision [9], takes
more inspiration from classical complexity theory. In his PODC 2010 keynote talk [ 12],
Fraigniaud suggested that decision problems, on which standard complexity theory is built,
could also serve as the basis for a complexity theory of distributed computing. The rationale
is that decision problems are easier to reduce to one another than construction problems,
while still being general enough to express challenges that arise in a wide variety of models of
distributed computing. Reductions between such problems could therefore reveal connections
between different areas of distributed computing, or even connections to other fields.
To make joint decisions in a distributed setting, the simplest and most widely studied
mechanism is acceptance by unanimity. This requires all computers to accept on yes-instances,
and at least one computer to reject on no-instances. When viewed in this context, LCL
can be reinterpreted as a class of decision problems on labeled graphs, which we will refer
to asgraph properties . The idea is that a graph is a yes-instance of a given graph property
if its labeling represents a valid solution to the corresponding LCLproblem (e.g., a valid
coloring, or a maximal independent set). By generalizing this to arbitrary graphs with labels
of arbitrary size, we arrive at the class of graph properties that are decidable in constant
round time in the localmodel. This class was given the name LD(forlocal decision )
in [14]. Following the above analogy with centralized computing, one can think of LDas a
distributed analog of the complexity class P.
Nondeterminism. Problems in LDare by definition purely local, and it is easy to come
up with graph properties that lie outside this class. For instance, the nodes of a graph
cannot locally decide whether the graph is a tree (again, because a sufficiently long cycle is
indistinguishable from a line). However, a much larger class of properties can be verified
if we take inspiration from the complexity class NPand allow some external entity to
nondeterministically assign each node an additional label that acts as a certificate. In fact,
if arbitrary certificates are allowed, then the nodes can verify any property decidable by a
single computer in the centralized setting, because each certificate can in principle encode
the entire graph along with the node’s identifiers (see, e.g., [8, §4.1]).
To obtain more interesting complexity classes, two types of restrictions on the certificates
have been considered in the literature. The first is to require the certificates to be independent
of the nodes’ identifiers. Fraigniaud, Korman, and Peleg [ 14] explored this restriction in a
modelcalled nondeterministic local decision andshowedthatitstrictlyweakensexpressiveness,
as some properties dependent on the number of nodes in the graph can no longer be locally
verified. (It was subsequently shown that the non-verifiable properties are precisely those
that are not closed under lift [ 13].) The full power of unrestricted certificates can only
be recovered in combination with additional resources such as randomization or an oracle
providing the number of nodes.F. Reiter 3
The second type of restriction limits the size of certificates with respect to the total
number of nodes. This idea was introduced by Korman, Kutten, and Peleg [ 23] in a model
calledproof labeling schemes , and further developed by Göös and Suomela [ 18] in a more
general model called locally checkable proofs . As later argued by Feuilloley [ 8], certificate
size provides, in a sense, an alternative measure of locality: purely local properties do not
require any certificates, while inherently global properties require quadratic-size certificates
(to encode an adjacency matrix of the entire graph). The property of 3-colorability is almost
local, requiring only constant-size certificates, and interestingly, many natural properties
such as non- 2-colorability and Hamiltonicity require logarithmic-size certificates.
Alternation. Since nondeterminism with restrictions on the certificates provides additional
power, but not enough to express all graph properties, a natural follow-up is to explore
more computational resources from standard complexity theory and assess their impact on
expressiveness. One such resource is quantifier alternation, the key concept underlying the
polynomial hierarchy (a hierarchy of complexity classes that contains P,NP, andcoNPat its
lowest levels). Adapted to the localmodel, alternation can be thought of as a game between
two players, Eve and Adam, who take turns assigning certificates to all nodes. Intuitively, Eve
(the existential player) tries to prove that the input graph satisfies a given property, while
Adam (the universal player) tries to disprove it. A constant-round-time distributed algorithm
then serves as an arbiter to determine the winner based on the certificates provided.
This framework was investigated by Balliu, D’Angelo, Fraigniaud, and Olivetti [ 3] for
identifier-independent certificates, and by Feuilloley, Fraigniaud, and Hirvonen [ 10] for
logarithmic-size certificates. The two resulting alternation hierarchies turned out to be
radically different. In the case of identifier-independent certificates, a single alternation
between Adam and Eve already suffices to arbitrate any property decidable in the centralized
setting. This means that the entire hierarchy collapses to its second level. On the other hand,
for logarithmic-size certificates, there are graph properties that lie outside the corresponding
hierarchy, and it remains open whether the hierarchy is infinite. The latter question is
believed to be difficult, as it has been shown to be closely related to a long-standing open
problem in communication complexity [11].
1.2 Contribution
ThispaperismotivatedbythefollowingquestionraisedbyFraigniaud, Korman, andPeleg[ 14,
§5.1]:What are the connections between classical computational complexity theory and local
complexity theory? Rather than viewing the classical theory as merely a source of inspiration,
we aim to extend it directly to the setting of distributed decision. We approach this from the
perspective that centralized computing corresponds to a special case of the localmodel,
where the network consists of a single computer. More specifically, we introduce the class LP
(forlocal-polynomial time ), which consists of the graph properties that can be decided in a
constant number of rounds in the localmodel under the following constraints: the number
of computation steps of each computer in each round must be polynomially bounded by
the size of its local input and the messages received, and the algorithm must work correctly
even under identifier assignments that are only locally unique within a fixed radius. This
class generalizes both the complexity class P(its restriction to graphs consisting of a single
labeled node), and the class of LCLdecision problems (its restriction to graphs of bounded
maximum degree and constant label size).
Building on LP, we then define the local-polynomial hierarchy {Σlp
ℓ,Πlp
ℓ}ℓ∈Nanalogously
to the alternation hierarchies mentioned above, i.e., as a game between Eve and Adam4 A LOCAL View of the Polynomial Hierarchy
who alternately assign certificates to all nodes. The size of these certificates must be
polynomially bounded with respect to a constant-radius neighborhood of the nodes. Hence,
when restricted to single-node graphs, our hierarchy coincides exactly with the classical
polynomial hierarchy. For example, the restriction of Σlp
1=NLPto single-node graphs
coincides with the complexity class Σp
1=NP. Aiming more at a conceptual than a technical
contribution, we make three main points:
1.Several key concepts and results from standard complexity theory generalize well to the
distributed setting. To illustrate this, we extend the notion of polynomial-time reductions
to our model of computation, and then use it to establish a number of hardness and
completeness results for the two lowest levels of the local-polynomial hierarchy. While
some of these are meaningful only in the distributed setting, our results also include
distributed generalizations of well-known classics, in particular the Cook–Levin theorem
(which identifies Boolean satisfiability as a complete problem for NP), and the fact
that 3-colorability is NP-complete. Similarly, we prove a distributed generalization of
Fagin’s theorem (which characterizes NPas the problems expressible in existential second-
order logic). This gives us a logical, and thus machine-independent, characterization
of the entire local-polynomial hierarchy, demonstrating the robustness of our definition.
Moreover, whenever we generalize a classical result, the original version can be recovered
by restricting networks to single computers.
2.Sometimes standard techniques get us further in the distributed setting than they do in the
centralized setting. Specifically, we are able to show that the local-polynomial hierarchy
is infinite, while it remains notoriously open whether this is also true when restricted
to a single computer. (A collapse of our hierarchy would have implied a collapse of the
classical polynomial hierarchy, but the converse does not hold.) As a consequence, our
hardness and completeness results for the local-polynomial hierarchy immediately yield
unconditional lower bounds on the complexity of the graph properties in question, i.e.,
lower bounds that do not rely on any complexity-theoretic assumptions. In addition,
the constraints imposed by the distributed setting allow us to identify natural graph
properties that lie outside our hierarchy.
3.Descriptive complexity theory, the discipline of characterizing complexity classes in terms
of equivalent logical formalisms, is particularly helpful in the distributed setting.
On the one hand, this approach gives us access to a large body of existing results in logic
and automata theory. In particular, our infiniteness result for the local-polynomial
hierarchy leverages a corresponding result on monadic second-order logic established
by Matz, Schweikardt, and Thomas [ 29], as well as a logical characterization of finite
automata on pictures (so-called tiling systems) established by Giammarresi, Restivo,
Seibert and Thomas [ 16]. Despite not being explicitly concerned with distributed
computing, these results rely significantly on a form of locality. Moreover, to show
that some graph properties lie outside our hierarchy, we make direct use of classical
results from automata theory, namely the pumping lemma for regular languages and
the Büchi-Elgot-Trakhtenbrot theorem (which provides a logical characterization of
finite automata on words).
On the other hand, descriptive complexity can offer a fresh perspective on distributed
computing by imposing unconventional constraints that shed new light on familiar
concepts. For instance, the restriction to algorithms that work correctly under locally
unique identifiers is necessary to prove our generalization of Fagin’s theorem. But this
restriction is also meaningful from a pure distributed computing point of view: in a
sense, LPfully preserves the locality of LCL(which can be defined without identifiers),F. Reiter 5
whereas LDis somewhat less local due to its reliance on globally unique identifiers.
Similarly, proving our generalization of Fagin’s theorem requires a polynomial bound
on the certificate sizes with respect to the constant-radius neighborhoods of the nodes.
This again places a strong emphasis on locality, and contrasts sharply with previous
approaches to distributed nondeterminism and alternation, which allow certificate sizes
to depend on the whole graph. As a consequence, our approach may provide a new
way tomeasure the locality of problems in distributed computing, a prospect we will
discuss in Section 10.
1.3 Related work
Our base class LPgeneralizes the LCLproblems of Naor and Stockmeyer [ 31] to arbitrary
labeled graphs (when interpreting these problems as decision problems). However, it is less
general than the class LDof Fraigniaud, Korman, and Peleg [ 14], since it imposes restrictions
on the individual processing power of the nodes and requires correctness under locally unique
identifiers. Hence, we have LCL⊆LP⊆LD, and it is easy to check that these inclusions
are strict.
Alternation hierarchies. The work most closely related to this paper includes the different
alternation hierarchies based on LD. The relationship is particularly clear for the previously
mentioned identifier-independent hierarchy {indΣld
ℓ,indΠld
ℓ}ℓ∈Nof Balliu, D’Angelo, Fraig-
niaud, and Olivetti [ 3]. Since that hierarchy collapses to its second level indΠld
2and contains
all decidable properties, it obviously subsumes our hierarchy {Σlp
ℓ,Πlp
ℓ}ℓ∈N, which is infinite
and excludes some decidable properties. But even on the lower levels, it is easy to see that
Σlp
ℓ⊆indΣld
ℓandΠlp
ℓ⊆indΠld
ℓ, essentially because the identifier-independent certificates
chosen by the first player can be used to provide each node with a new, locally unique
identifier whose validity can be verified in a constant number of communication rounds. The
inclusion on the nondeterministic level is strict because not-all-selected , the property of
a labeled graph having at least one unselected node, lies in indΣld
1but not in Σlp
1.
Recently, apolynomial-timeversion {indΣld/p
ℓ,indΠld/p
ℓ}ℓ∈Noftheidentifier-independent
hierarchy was investigated by Aldema Tshuva and Oshman [ 39]. Although at first glance their
definition may seem similar to ours, it differs in a crucial point: the polynomial bound they
impose on the processing time of the nodes is relative to the size of the entire input graph
(including labels), rather than relative to the amount of information that the nodes receive
locally. As a result, from its second level indΠld/p
2onward, their hierarchy is essentially
equivalent to the centralized polynomial hierarchy (restricted to encodings of graphs), and
thus it is unknown whether it collapses or not. Nevertheless, its relationship to our hierarchy
mirrors that of the original identifier-independent hierarchy, i.e., Σlp
ℓ⊆indΣld/p
ℓand
Πlp
ℓ⊆indΠld/p
ℓfor allℓ∈N, and the property not-all-selected separates indΣld/p
1
fromΣlp
1.
It is less obvious how exactly our hierarchy relates to the previously mentioned logarithmic-
size hierarchy{logΣld
ℓ,logΠld
ℓ}ℓ∈Nof Feuilloley, Fraigniaud, and Hirvonen [ 10]. But at least
when restricted to graphs of bounded maximum degree and constant label size, each level
of the logarithmic-size hierarchy contains the corresponding level of our hierarchy, since
our bound on the certificates sizes reduces to a constant bound for such graphs. That
is,Σlp
ℓ|graph (∆)⊆logΣld
ℓ|graph (∆)andΠlp
ℓ|graph (∆)⊆logΠld
ℓ|graph (∆), where C|graph (∆)
denotes the aforementioned restriction of a class C. Moreover, the nondeterministic classes
are again separated by the property not-all-selected , which lies in logΣld
1but not in Σlp
1.6 A LOCAL View of the Polynomial Hierarchy
What most fundamentally distinguishes this work from all three LD-based hierarchies is
that our hierarchy preserves some degree of locality. This is because we bound the size of a
node’s certificates with respect to its constant-radius neighborhood, so that each certificate
can encode only a very limited amount of global information about the input graph. By
contrast, in both identifier-independent hierarchies, “only the first few levels of alternation
are needed to overcome the locality of a distributed algorithm”, as noted by Aldema Tshuva
and Oshman [ 39, §1]. This is particularly evident in the original version of Balliu, D’Angelo,
Fraigniaud, and Olivetti, where the second level indΠld
2already contains all global properties.
Similarly, in the logarithmic-size hierarchy of Feuilloley, Fraigniaud, and Hirvonen, the third
levellogΣld
3is already powerful enough to express the existence of a nontrivial automorphism,
a property that is inherently global when using certificate size as the measure of locality.
(Göös and Suomela [18] have shown that it requires quadratic-size certificates, which is the
highest possible complexity).
Descriptive complexity. Another line of research closely related to this paper is the devel-
opment of descriptive complexity in the setting of distributed computing. This was initiated
by Hella et al. [ 20], who used several variants of modal logic to characterize synchronous
constant-round-time algorithms for various models of distributed computing in anonymous
networks. Their idea was later extended to arbitrary-round-time algorithms [ 24], asyn-
chronous algorithms [ 34], and a stronger model with unique identifiers [ 4]. Our generalization
of Fagin’s theorem to the localmodel remains close in spirit to the work of Hella et al. The
main difference is that we consider polynomial-time Turing machines instead of finite-state
automata, and bounded first-order quantifiers instead of modal operators. Also, the result of
Hella et al. already holds for deterministic models, whereas our result requires the presence of
nondeterminism, or more generally, alternation. This parallels the situation in the centralized
setting, where Fagin’s theorem characterizes the class NP, but it remains a major open
question whether the class Padmits a similar characterization.
Construction problems. More distantly related to this paper, recent years have also
seen significant progress in the study of LCLproblems as originally defined by Naor and
Stockmeyer (i.e., as construction problems whose solutions can be verified locally). Much
research has focused on classifying LCLproblems according to the round time required to
construct solutions for them in the localmodel. For over two decades, progress was slow as
efforts were driven by individual problems rather than entire classes of problems. While there
were known examples of LCLproblems with constant, iterated logarithmic, and linear round-
time complexities, it remained unclear whether problems with other complexities existed
in the spectrum between constant and linear round time. However, this picture changed
drastically in the mid 2010’s, when a large number of positive and negative results were
published within a few years, proving the existence of problems in someintermediate regions of
the spectrum, and ruling out the existence of problems in other regions. Taken together, those
results now provide a nearly complete classification of LCLproblems, revealing essentially
four complexity classes. In his SWAT 2020 keynote talk [ 37], Suomela interpreted those
classes as follows: purely local problems, symmetry-breaking problems, inherently global
problems, and an intriguing class of problems for which randomness provides a significant
speedup. As the topic is well beyond the scope of this paper, and the publications are
numerous, the reader is referred to (the transcript of) Suomela’s talk, which summarizes
recent progress and provides many references.F. Reiter 7
1.4 Organization
We begin with an informal overview of the paper in Section 2. The material covered there will
be repeated later in much greater detail and formality. This is necessary because descriptive
complexity involves mechanical translations between algorithms and logical formulas, forcing
us to deal with the low-level aspects of both frameworks. In Section 3, we give some
preliminaries on graphs and relational structures. Then, in Section 4, we introduce our
model of computation, which extends standard Turing machines to the distributed setting,
and define the local-polynomial hierarchy based on this model. Section 5 introduces the
corresponding logical formalism, along with some examples of graph properties expressed as
logical formulas. In Section 6, we provide a more flexible characterization of our complexity
classes in order to simplify subsequent proofs. The actual results begin in Section 7, where we
present Fagin’s theorem and generalize it to the local-polynomial hierarchy. In Section 8, we
introduce the notion of local-polynomial reductions, based on which we establish a number of
hardness and completeness results, including a generalization of the Cook–Levin theorem and
theNLP-completeness of 3-colorability. Section 9 constitutes the longest part of the paper,
where we prove that the local-polynomial hierarchy is infinite. This involves a detour through
tiling systems and monadic second-order logic on pictures. Finally, in Section 10, we discuss
how the preceding results may be relevant to the study of locality in distributed computing.
2 Informal overview
In this paper, we study the computational complexity of graph properties in terms of a
distributed model of computation. As is common in this type of setting, we always assume
that graphs are finite, simple, undirected, and connected. In addition, our graphs are
equipped with a labeling function that assigns a bit string to each node. The focus is
exclusively on graph properties that are invariant under isomorphism. These properties
typically depend on the graph’s topology (e.g., 3-colorability, Eulerianness, or Hamiltonicity),
but may also depend on its node labels (e.g., having all nodes labeled the same, or having
the labeling form a valid 3-coloring).
2.1 Our complexity classes
To classify graph properties, we extend standard complexity classes from strings to graphs,
treating strings as graphs consisting of a single labeled node.
Model of computation. We use distributed algorithms as decision procedures for graph
properties. Given an input graph Gand an assignment idof identifiers to the nodes of G,
the goal is for the nodes to collectively decide whether Ghas a certain property L. To do so,
they proceed in a sequence of synchronous communication rounds. In each round, each node
first receives the messages sent by its neighbors in the previous round, then performs some
local computations, and finally sends new messages to its neighbors. After a finite number of
rounds, each node must have reached an individual verdict, and Gis accepted if and only
if the nodes unanimously agree on it. The collective decision must be independent of the
particular identifier assignment id, as long as the latter satisfies a basic requirement of local
uniqueness :idmust assign different identifiers to any two nodes that lie within some fixed
distance of each other. This can be seen as a precondition for the algorithm to work correctly.
In the following, we restrict our attention to distributed algorithms that are guaranteed
to terminate in a constant number of communication rounds, and where the number of8 A LOCAL View of the Polynomial Hierarchy
computation steps of each node in each round is polynomially bounded by the size of its
local input and the messages it receives. We call such algorithms local-polynomial machines ,
as we will formalize them using a model based on Turing machines (see Section 4).
The local-polynomial hierarchy. Our complexity classes are based on a game between
two players who intuitively argue whether a given graph Ghas some property L: Eve
(the existential player) tries to prove that Ghas property L, and Adam (the universal
player) tries to prove the opposite. Given some locally unique identifier assignment of G, the
two players take turns choosing assignments of additional labels, called certificates, to the
nodes ofG. These certificates can be thought of as proofs (in Eve’s case) and counterproofs
(in Adam’s case). They may depend on the provided identifiers, but their size must be
polynomially bounded with respect to the amount of information contained in a node’s
constant-radius neighborhood (including all labels and identifiers therein). After a fixed
numberℓof moves, the winner is determined by a local-polynomial machine, which acts as an
arbiter. Ultimately, the graph Ghas property Lif and only if Eve has a winning strategy in
this game, i.e., if she always wins when playing optimally. Depending on who makes the first
move,Lis classified as a Σlp
ℓ-property (if Eve starts) or a Πlp
ℓ-property (if Adam starts).
To give an example, Lbelongs to Σlp
3if it satisfies the following equivalence for every
graphGand every admissible identifier assignment idofG:
G∈L⇐⇒ ∃κ1∀κ2∃κ3:M(G,id, κ1·κ2·κ3)≡accept,
whereMis an appropriately chosen local-polynomial machine, and all quantifiers range over
certificate assignments that satisfy the aforementioned polynomial bound. (The notation
used here will be formally introduced in Section 4.)
We refer to the family of classes {Σlp
ℓ,Πlp
ℓ}ℓ∈Nas thelocal-polynomial hierarchy . Two
classes at the lowest levels are of particular interest: LP=Σlp
0(forlocal-polynomial time )
andNLP =Σlp
1(fornondeterministic local-polynomial time ). Due to the asymmetric nature
of acceptance by unanimity, classes on the same level of the local-polynomial hierarchy
are neither complement classes of each other, nor are they closed under complementation
(see Corollary 38 on page 63). Therefore, it makes sense to also consider the hierarchy of
complement classes {coΣlp
ℓ,coΠlp
ℓ}ℓ∈N. The two hierarchies are illustrated in Figure 1, along
with the inclusion and separation results shown in this paper.
Connection to standard complexity classes. By restricting the classes Σlp
ℓandΠlp
ℓto
strings (i.e., labeled graphs consisting of a single node), we obtain the corresponding classes
Σp
ℓandΠp
ℓof the original polynomial hierarchy introduced by Meyer and Stockmeyer [ 30].
Since the same observation holds for the complement classes, this means that the local-
polynomial hierarchy is identical to its complement hierarchy on strings. In particular,
P=LP|node=coLP|nodeandNP=NLP|node=coΠlp
1|node, where C|nodedenotes the
restriction of a complexity class Cto single-node graphs. This means that any inclusion
result for the local-polynomial hierarchy would imply the corresponding inclusion result
for the polynomial hierarchy (e.g., LP=NLPwould imply P=NP), but not vice versa.
Conversely, any separation result for the polynomial hierarchy would imply the corresponding
separation result for the local-polynomial hierarchy (e.g., P̸=NPwould imply LP̸=NLP),
but not vice versa. Thus, unfortunately, our infiniteness result for the local-polynomial
hierarchy does not imply a corresponding result for the original polynomial hierarchy.F. Reiter 9
LPΣlp
1 Πlp
1Σlp
2 Πlp
2Σlp
3 Πlp
3Σlp
4 Πlp
4...
coLPcoΣlp
1 coΠlp
1coΣlp
2 coΠlp
2coΣlp
3 coΠlp
3coΣlp
4 coΠlp
4...
Σlp
1Σlp
2Σlp
3
Σlp
0= =Πlp
0NLP =
coΣlp
0= =coΠlp
0coNLP =
Figure 1 The local-polynomial hierarchy (left) and its complement hierarchy (right). The dotted
classes on the far right are the same as those on the far left, repeated for the sake of readability. Only
the lowest five levels are shown, but the pattern extends infinitely. (See Figure 11 on page 47 for an
extended version of this figure with references to the corresponding proofs.) Each line (whether solid
or dashed) indicates an inclusion of the lower class in the higher class. All inclusions represented by
solid lines are proved to be strict, and classes on the same level (regardless of which hierarchy) are
proved to be pairwise distinct, even when restricted to graphs of bounded maximum degree and
constant label size. The inclusions represented by dashed lines are in fact equalities when restricted
to the latter class of graphs, but this statement is unlikely to generalize to arbitrary graphs, where
it holds if and only if P=coNP. This means that from a distributed computing perspective, the
classes shown with thick borders are the most meaningful.
2.2 Extending classical reductions
Aiming to apply standard techniques of complexity theory to the distributed setting, we
extend Karp’s [22] notion of polynomial-time reduction to computer networks.
Local-polynomial reductions. In a nutshell, if there is a local-polynomial reduction from a
propertyLtoaproperty L′, thenthismeansthatthereexistsalocal-polynomialmachine Mred
that transforms an input graph Ginto a new graph G′such thatGhas property Lif and
only ifG′has property L′. Hence, the existence of such a reduction implies that L′is at
least as hard as L, since an efficient decider M′forL′could be converted into an efficient
deciderMforL, which would first run Mredand then simulate M′on the resulting graph.
To transform a graph Ginto a graph G′with a distributed algorithm, each node u
of the input graph Gcomputes a string that encodes a subgraph of the output graph G′,
including the labels of all nodes therein. We call this subgraph the clusterrepresenting u
inG′. Clusters of different nodes may not overlap, and edges between different clusters are
only permitted if the clusters represent adjacent nodes in the original graph G. This setup
allows the nodes of Gto simulate a distributed algorithm running on G′by simulating the
algorithm within their respective clusters and exchanging messages with their neighbors to
simulate inter-cluster communication. (For a more formal presentation, see Section 8.)
Hardness and completeness results. Given the above notion of reduction, our definitions
of hardness and completeness for different levels of the local-polynomial hierarchy should
come as no surprise: a graph property Lis hard for a complexity class Cif there is a10 A LOCAL View of the Polynomial Hierarchy
local-polynomial reduction to Lfrom every graph property in C, andLis complete for Cif
itself additionally lies in that class.
The basic approach to establishing reductions between specific problems in our setting
is quite similar to that in the centralized setting, so conventional techniques continue to
work well. Using fairly simple constructions, we can show that Eulerianness is LP-complete,
while Hamiltonicity is both LP-hard and coLP-hard. Because of the incomparability of LP
andcoLP(see Figure 1), this immediately tells us that Hamiltonicity is a strictly harder
problem than Eulerianness in our model of computation. What’s more, we can sometimes
even build directly on classical reductions by extending them to the distributed setting. In
particular, we can generalize the Cook–Levin theorem from NPtoNLPand, based on
that, establish the NLP-completeness of 3-colorability. Again, this has direct implications:
3-colorability is neither in LPnor in coNLP, since both classes are separate from NLP. We
now sketch two of the above reductions as examples. (More details are given in Section 8.)
An LP-hardness proof. To show that Hamiltonicity is LP-hard, we provide a reduction to
it from all-selected , a trivially LP-complete graph property that requires all nodes to be
labeled with the bit string 1. This reduction is illustrated in Figure 2.
Given an arbitrary graph G, we construct a graph G′that has a Hamiltonian cycle if
and only if all nodes of Ghave label 1. The main idea is that a Hamiltonian cycle in G′
represents a depth-first traversal of a spanning tree of G, using a method known as the
Euler tour technique. For this purpose, each edge of Gis represented by two edges in G′, so
that it can be traversed twice by a Hamiltonian cycle in G′. If all nodes of Gare labeled
with 1, then any spanning tree of Gyields a Hamiltonian cycle of G′. However, if at least one
node ofGhas a label different from 1(such as node u2in Figure 2), then our construction
includes an additional node of degree 1to ensure that G′is not Hamiltonian. Note that the
nodes ofGcan compute G′in a constant number of communication rounds and a number of
computation steps polynomial in the size of their local input and the messages they receive.
(For more details, see Proposition 16 on page 41.)
cluster ofu1 cluster ofu2
cluster ofu3 cluster ofu4G′:
u1 u2
u3 u41 0
1 1G:
Figure 2 Example illustrating the reduction from all-selected tohamiltonian , used to show
that the latter is LP-hard. The graph Ghas all node labels equal to 1if and only if the graph G′
has a Hamiltonian cycle. The thick edges in Gform a spanning tree, which is replicated by the thick
edges inG′. In this particular case, if node u2ofGhad label 1, then its cluster in G′would lack the
“central” node, and thus the thick edges in G′would form a Hamiltonian cycle.F. Reiter 11
An NLP-completeness proof. 3-colorability clearly lies in NLP. To show that it is also
NLP-hard, we build on the classical reduction from 3-satto the string-encoded version of
3-colorability, which gives us the desired result almost for free. Our extension of this
construction to the distributed setting is illustrated in Figure 3. Here we generalize 3-sat
to graphs as follows to obtain an NLP-complete property: each node of the input graph
is labeled with a Boolean formula, and the graph is said to be satisfiable if there exists an
assignment of variable valuations to its nodes such that each valuation satisfies the formula
of the corresponding node while being consistent with the valuations of all adjacent nodes.
(Two adjacent nodes can have different variables, but any variables shared by both must be
assigned the same values.)
Given an input graph G, we construct a graph G′that is 3-colorable if and only if Gis
satisfiable. For this purpose, each node of Gis represented by a cluster that encodes its
formula in such a way that a valid 3-coloring of the cluster represents a satisfying valuation
of the formula. This is done by directly using the classical construction as it stands. In
addition, to ensure that the variable valuations of adjacent nodes are consistent for all shared
variables, the corresponding clusters are connected with auxiliary gadgets that force certain
nodes to have the same color. Again, the nodes of Gcan compute G′in a constant number
of communication rounds and a polynomial number of computation steps. (For more details,
see Theorem 20 on page 45; for the classical reduction, see, e.g., [17, Prp. 2.27].)
false
ground
P1¯P1P2¯P2P3¯P3clause
gadget
formula
gadgetfalse
ground
P3¯P3P4¯P4P5¯P5clause
gadgetformula
gadget
cluster representing node u cluster representing node vG′:u v P1∨¯P2∨¯P3 P3∨P4∨¯P5 G:
Figure 3 Example illustrating the reduction from 3-sat-graph to3-colorable , used to show
that the latter is NLP-complete. The Boolean graph Gis satisfiable if and only if the graph G′is
3-colorable. The labels in G′serve explanatory purposes only and are not part of the graph.
2.3 A logical characterization
A central tool and recurring theme of this paper is Fagin’s theorem [ 7]. In its original form
(see Theorem 9 on page 29), it states that a formal language lies in NPif and only if it
can be defined by a formula of existential second-order logic. Such formulas are of the form
∃R1...∃Rnφ, whereR1,...,Rnare second-order variables and φis a first-order formula. In
the context of this paper, these formulas are evaluated on bit strings represented as relational12 A LOCAL View of the Polynomial Hierarchy
structures. More precisely, the bits of a string are represented by a sequence of elements
connected by a binary successor relation, and their values are determined by a unary relation.
For instance, the string 010011is represented by the structure
,
where the elements belonging to the unary relation are marked in black.
Extension to the distributed setting. We show that Fagin’s result can be generalized to
obtain a similar logical characterization of the class NLP(see Theorem 11 on page 31). To
evaluate logical formulas on labeled graphs, we use the structural representation illustrated
in Figure 4. This representation contains an element for every node and every labeling bit of
the graph. The nodes are connected symmetrically to their neighbors and asymmetrically
to their labeling bits by two binary relations. In turn, the labeling bits of each node are
interconnected by a successor relation and assigned a value by a unary relation, just as in
the string representation described above.
010
10 1101001
G: $G:
Figure 4 A labeled graph Gand its structural representation $G. For later reference: the unary
relation⊙$G
1is represented by black elements, and the binary relations ⇀$G
1and⇀$G
2by solid and
dotted arrows, respectively.
Our generalization of Fagin’s theorem states that a graph property lies in NLPif and
only if it can be defined (on structural representations as above) by a formula of the following
fragment of existential second-order logic: formulas are of the form ∃R1...∃Rn∀xφ, where
R1,...,Rnare second-order variables, xis a first-order variable, and φis a first-order
formula in which all quantifiers are bounded to range only over locally accessible elements.
For instance, existential quantification must be of the form ∃z−⇀↽−yψ, which can be read as
“there exists an element zconnected to a known element ysuch that formula ψis satisfied”.
This means that first-order quantification in φis always relative to some element already
fixed at an outer scope, and thus in effect that φisbounded around the variable x. (For
formal definitions and examples, see Section 5.)
Extension to higher levels of alternation. Stockmeyer [ 36] showed that Fagin’s theorem
extends to the higher levels of the polynomial hierarchy. For example, the complexity
classΠp
2is characterized by formulas of the form ∀R1...∀Rm∃S1...∃Snφ, consisting of a
block of universal second-order quantifiers, followed by a block of existential second-order
quantifiers, and then a first-order formula φ. We similarly extend our generalization of
Fagin’s theorem to the higher levels of the local-polynomial hierarchy (see Theorem 12 on
page 35). For instance, the complexity class Πlp
2is characterized by formulas of the form
∀R1...∀Rm∃S1...∃Sn∀xφ, where the prefix of second-order quantifiers is as above, xis aF. Reiter 13
first-order variable, and φis a first-order formula bounded around x. We refer to this logical
characterization of the local-polynomial hierarchy as the local second-order hierarchy . All
graph properties in this hierarchy can be defined by formulas consisting of alternating blocks
of existential and universal second-order quantifiers, followed by a single universal first-order
quantifier, and then a bounded first-order formula.
For each alternation level, we can recover Stockmeyer’s result by restricting our corre-
sponding statement to single-node graphs. Indeed, if the input graph consists of a single node,
then all elements of its structural representation lie within distance 2of each other, so the
distinction between bounded and unbounded first-order quantification becomes irrelevant.
Proof outline. Unfortunately, there does not seem to be a straightforward way to use
Fagin’s original result as a black box to prove our generalization. So instead, we give a
full proof from scratch, adapting the ideas of the original proof to the distributed setting.
Here we sketch only the nondeterministic case, which is the easiest to present, but the proof
extends to arbitrarily high levels of quantifier alternation.
The easy part is to translate a formula of the form ∃R1...∃Rn∀xφinto a distributed
Turing machine that verifies the same property. In essence, the certificates chosen by the
prover (Eve) are used to encode the existentially quantified relations R1,...,Rn, so that
the nodes executing the machine just have to run a local algorithm to evaluate φin their
constant-radius neighborhood. They can do this in a polynomial number of computation
steps by simply iterating over all possible interpretations of the first-order variables in φ.
The reverse translation, however, is more complicated. It involves encoding the space-
time diagram of every Turing machine in the network by a collection of relations over the
corresponding structural representation. The key insight that makes this possible is the
same as in Fagin’s original proof: since the number of computation steps of each machine
is polynomially bounded by the size of its input, each cell of the corresponding space-time
diagram can be represented by a tuple of nearby elements whose length depends on the
degree of the bounding polynomial. What makes our generalized proof somewhat more
cumbersome are the additional technicalities imposed by the distributed setting, in particular
the assignment of locally unique identifiers (chosen small enough to be representable), and
the exchange of messages between adjacent nodes. The latter requires that, for each pair of
adjacent machines, our formula keeps track of the tape positions of the sent and received
messages, so that the appropriate section of one machine’s sending tape is copied to the
appropriate section of the other machine’s receiving tape.
Implications. Our generalization of Fagin’s theorem serves several purposes in this paper:
1.It provides evidence that our definition of the local-polynomial hierarchy is robust, in the
sense that the complexity classes defined do not inherently depend on technical details
such as the chosen model of computation.
2.It gives us a convenient way to prove our generalization of the Cook–Levin theorem
mentioned above. This is analogous to the centralized setting, where the Cook–Levin
theorem can be obtained as a corollary of Fagin’s theorem.
3.As we will see next, we make extensive use of the provided connection to logic to prove
that the local-polynomial hierarchy is infinite.
2.4 Infiniteness of our hierarchy
While in centralized computing the question of whether Pequals NPremains a major open
problem, the corresponding question in distributed computing—whether LPequals NLP—is14 A LOCAL View of the Polynomial Hierarchy
easily settled with an elementary argument: nondeterminism provides a means to break
symmetry, which is impossible in a purely deterministic setting (see Proposition 21 on
page 48). What seems less obvious, however, is how to separate complexity classes that lie
higher in the local-polynomial hierarchy. This is where our generalization of Fagin’s theorem
proves particularly helpful, as it allows us to reformulate the problem in the well-studied
framework of logic and automata theory. Our separation proof builds on two results from
that area, both concerning monadic second-order logic on pictures. The main ideas are
outlined below.
Logic on pictures. Monadic second-order logic is the fragment of second-order logic that
can only quantify over sets instead of arbitrary relations. This means, for instance, that the
formulas of existential monadic second-order logic are of the form ∃X1...∃Xnφ, where the
variablesX1,...,Xnrepresent sets of elements and φis a first-order formula.
Meanwhile, picturesare matrices of fixed-length binary strings. To describe the properties
of pictures using logical formulas, every picture is given a structural representation as shown
in Figure 5. Specifically, the entries of the picture are represented by elements connected by
a “vertical” and a “horizontal” successor relation, and the value of each bit is represented by
a unary relation. (Formal definitions are given in Section 9.2.)
00 01 00 01
10 11 10 11
00 01 00 01

P: $P:
Figure 5 A2-bit picture Pand its structural representation $P.
Proof outline. Our proof of the infiniteness of the local-polynomial hierarchy consists of
two main parts, which remain mostly in the realm of logic:
1.First, we show that the local second-order hierarchy is infinite when restricted to pictures,
and more precisely that all levels ending with a block of existential quantifiers are distinct
(see Section 9.2.1). This is obtained by combining the following two results:
a.We show that the local and the monadic second-order hierarchies on pictures are
levelwise equivalent for all levels ending with a block of existential quantifiers. The
main ingredient to prove this is an automata-theoretic characterization of existential
monadic second-order logic on pictures due to Giammarresi, Restivo, Seibert, and
Thomas [ 16] (see Theorem 29 on page 53). This characterization, which is itself based
on a locality property of first-order logic, gives us a convenient way to establish the
equivalence of the existential fragments of local and monadic second-order logic on
pictures. For the higher levels of the hierarchies, the equivalence is then obtained by
induction on the number of quantifier alternations.
b.Matz, Schweikardt, and Thomas [ 29] have shown that the monadic second-order
hierarchy on pictures is infinite (see Theorem 27 on page 51). Interestingly, one way
to prove their result is based on the automata-theoretic characterization mentioned
above, and thus ultimately on the same locality property of first-order logic.
2.Second, we transfer the previous infiniteness result for the local second-order hierarchy
from pictures to graphs (see Section 9.2.2). We do this by encoding pictures as graphsF. Reiter 15
in such a way that formulas can be translated from one type of structure to the other
without changing the alternation level of second-order quantifiers. By our generalization
of Fagin’s theorem, this implies that all levels of the local-polynomial hierarchy ending
with a block of existential quantifiers are distinct (see Theorem 33 on page 59). We then
complete this partial separation result with some additional arguments to arrive at the
fuller separation result shown in Figure 1 (see Sections 9.1 and 9.3).
Implications. Besides the result itself, we derive two main benefits from the infiniteness of
the local-polynomial hierarchy:
1.Hardness results give us unconditional lower bounds. That is, if we can show that a graph
property is hard for some class of the hierarchy, then we immediately know that it does
not lie in the classes below (see Corollaries 22, 25, and 26 starting on page 49).
2.Since alternation is the only way for nodes to obtain global information about their
network, the infiniteness result also suggests that the local-polynomial hierarchy may
provide a new way to measure the locality of problems in distributed computing (see the
discussion in Section 10).
3 Preliminaries
We denote the empty set by ∅, the set of nonnegative integers by N, the set of positive
integers by N>0, and the set of integers by Z. The absolute value of an integer nis denoted
byabs(n). The cardinality of any set Ais written as card(A), its power set as 2A, and the
set of finite strings over AasA∗. The length of a string sis denoted by len(s), and itsi-th
symbol bys(i). By a slight abuse of notation, we sometimes lift functions from elements to
sets, i.e., given f:X→YandA⊆X, we writef(A)for{f(a)|a∈A}. To denote integer
intervals, we define [m:n]={i∈Z|m≤i≤n}and[n]=[0 :n], for anym,n∈Z. Angle
brackets indicate excluded endpoints, e.g., ⟨m:n] = [m+ 1 :n]and[n⟩= [0 :n−1].
Throughout this paper, we assume some fixed but unspecified encoding of finite objects
(e.g., integers, graphs, or tuples of finite objects) as binary strings. Sometimes we also
implicitly identify such objects with their string representations.
Graphs. All graphs we consider are finite, simple, undirected, and connected. Formally,
alabeled graph , or simply graph, is represented by a triple G= (VG,EG,λG), whereVG
is a finite nonempty set of nodes,EGis a set of undirected edgesconsisting of 2-element
subsets ofVGand containing, for every partition {V0,V1}ofVG, at least one edge {u,v}
withu∈V0andv∈V1, andλG:VG→{0,1}∗is alabelingfunction that assigns a bit string
to each node. We refer to the string λG(u)as thelabelof nodeuand to the symbol λG(u)(i)
as thei-thlabeling bit ofu, fori∈[1 : len(λG(u))]. To simplify notation, we often write
u∈Ginstead ofu∈VG, and we define card(G), thecardinality ofG, ascard(VG).
We denote by graphthe set of all labeled graphs and by nodethe set of single-node
graphs, i.e., labeled graphs consisting of a single node. A graph property (sometimes called
a “graph language”) is a set L⊆graphthat is closed under isomorphism. If a graph G
belongs toL, then we also say that Ghas the property L.
We follow Diestel [ 6] for standard graph-theoretic terms such as neighbor,degree,distance,
diameter ,induced subgraph , and so on. The diameter of a graph Gis denoted by diam (G).
Forr∈Nandu∈G, ther-neighborhood NG
r(u)ofuinGis the subgraph of Ginduced by
all nodes at distance at most rfromu. That is,NG
r(u)is the graph G′that consists of the16 A LOCAL View of the Polynomial Hierarchy
nodes at distance at most rfromuand all edges connecting them, and whose labeling λG′is
the restriction of λGtoVG′.
Identifierassignments. Anidentifier assignment ofagraphGisafunction id:VG→{0,1}∗
whosepurposeistodistinguishbetweendifferentnodesof G. Wereferto id(u)astheidentifier
of nodeuunder id. Identifiers are ordered lexicographically, i.e., the identifier order is such
that id(u)<id(v)if either id(u)is a proper prefix of id(v), orid(u)(i)<id(v)(i)at the first
positioniwhere the two strings differ.
We say that idisrid-locally unique for somerid∈Nif it satisfies id(u)̸=id(v)for all
distinct nodes uandvthat lie in the rid-neighborhood of a common node w(or equivalently,
in the 2rid-neighborhood of each other). If rid≥diam (G)/2, we say that idisglobally unique .
Anrid-locally unique identifier assignment idof a graphGis called small(with respect
torid) if for every node u∈G, the length of id(u)is at most⌈log2card(NG
2rid(u))⌉, i.e.,
logarithmically bounded by the cardinality of u’s2rid-neighborhood in G. When we want to
emphasize that an rid-locally unique identifier assignment is not necessarily small, we call it
arbitrary-sized .
▶Remark 1. For every graph Gand integer rid∈N, there exists an rid-locally unique
identifier assignment idofGthat is small.
Proof.By definition, an identifier assignment idofGisrid-locally unique if the identifier id(u)
of every node u∈Gis distinct from the identifiers of all other nodes in NG
2rid(u). Such an
identifier assignment can be easily constructed if we may choose among at least card(NG
2rid(u))
possible values of id(u). Hence, a bit string of length at most ⌈log2card(NG
2rid(u))⌉is
sufficient. ◁
Certificate assignments. For any graph Gand any identifier assignment idofG, acertificate
assignment of(G,id)is a function κ:VG→{0,1}∗. We refer to κ(u)as thecertificate of
nodeuunderκ. Givenr∈Nandp:N→N, we say that κis(r,p)-boundedif for every node
u∈G, the length of u’s certificate is bounded by pwith respect to the cardinality of u’s
r-neighborhood and the lengths of all labels and identifiers therein, i.e.,
len(κ(u))≤p(∑
v∈NG
r(u)1 + len(λG(v)) + len( id(v)))
.
We often represent several certificate assignments as a single function ¯κ:VG→{0,1,#}∗,
called acertificate-list assignment , where the symbol #is used to separate the individual
certificates of each node. Given certificate assignments κ1,κ2,...,κℓ, we writeκ1·κ2·...·κℓ
for the certificate-list assignment ¯κsuch that ¯κ(u) =κ1(u)#κ2(u)#...#κℓ(u)for allu∈G.
We say that ¯κis(r,p)-bounded ifκiis(r,p)-bounded for every i∈[1 :ℓ].
Structural representations. We will evaluate logical formulas on relational structures of
the formS= (DS,⊙S
1,...,⊙S
m,⇀S
1,...,⇀S
n), whereDSis a finite nonempty set of elements,
called the domainofS, each⊙S
iis a subset of DS, fori∈[1 :m], and each⇀S
iis a binary
relation over DS, fori∈[1 :n]. We refer to (m,n)as thesignature ofS. To simplify
notation, we often write a∈Sinstead ofa∈DS, and we define card(S), thecardinality ofS,
ascard(DS). We also write a−⇀↽−Sbto indicate that a⇀S
iborb⇀S
iafor somei∈[1 :n].
To evaluate logical formulas on graphs, we identify each graph Gwith a structure
$G= (D$G,⊙$G
1,⇀$G
1,⇀$G
2)of signature (1,2), called the structural representation ofG. ThisF. Reiter 17
structure contains one element ufor each node u∈Gand one element (u,i)for each of u’s
labeling bits, i.e.,
D$G=VG∪{(u,i)|u∈VG, i∈[1 : len(λG(u))]}.
The set⊙$G
1corresponds to the labeling bits whose value is 1, i.e., (u,i)∈⊙$G
1if and only
ifλG(u)(i)= 1. The relation ⇀$G
1represents the edges in EGand the successor relation of
the labeling bits, i.e., u⇀$G
1vif and only if{u,v}∈EG, and (u,i)⇀$G
1(v,j)if and only if
u=vandj=i+ 1. Finally, the relation ⇀$G
2determines which node owns which labeling
bits, i.e.,u⇀$G
2(v,i)if and only if u=v. An example is provided in Figure 4 on page 12.
Forr∈Nandu∈G, the structural representation of u’sr-neighborhood NG
r(u)is
denoted by N$G
r(u). For instance, if uis the upper right node of the graph Gdepicted in
Figure 4, then card(N$G
0(u)) = 4,card(N$G
1(u)) = 8, andN$G
2(u) = $G.
Astructure property is a setLof structures that is closed under isomorphism. In particular,
since we identify graphs with their structural representations, every graph property is also a
structure property. We will often restrict a given class Cof structure properties (e.g., NLP)
to structures that have some presupposed property K(e.g., node). In such cases, we write
C|Kfor the restriction of CtoK, i.e., C|K={L∩K|L∈C}.
4 Distributed Turing machines
We formalize synchronous distributed algorithms using the notion of distributed Turing
machines. As illustrated in Figure 6, such machines are equipped with three one-way infinite
tapes: areceiving tape to store incoming messages, an internal tape to store the machine’s
internal state and perform local computations, and a sendingtape to store outgoing messages.
⊢01#1001011#000#...
⊢001010011011110...
⊢11100#100110#01...qstatereceiving tape
internal tape
sending tapemessage from second neighbor
message to second neighbor
Figure 6 Local copy of a distributed Turing machine being executed by a node.
Formal representation. Adistributed Turing machine is represented by a tuple M= (Q,δ)
consisting of a finite set Qofstatesand atransition function δ:Q×Σ3→Q×Σ3×{− 1,0,1}3.
Here,Σis the tape alphabet {⊢,□,#,0,1}with the left-end marker⊢, theblank symbol □,
and theseparator #. We assume that Qalways contains the designated states qstart,qpause,
andqstop.
When we refer to the contentof a tape, we mean the sequence of symbols written on the
tape ignoring any leading or trailing occurrences of ⊢and□. In particular, if the first cell of
the tape contains ⊢and the remaining cells contain □, we consider the tape to be empty.
Execution. AdistributedTuringmachine M= (Q,δ)canbeexecutedonanygraph G, under
any identifier assignment idofGand any certificate-list assignment ¯κof(G,id), provided18 A LOCAL View of the Polynomial Hierarchy
that idis at least 1-locally unique. An execution consists of a sequence of synchronous
communication rounds , where all nodes start at the same time and run their own copy of M.
In every round, each node u∈Ggoes through three phases: (1) it receives messages from its
neighbors, (2) it performs local computations, and (3) it sends messages to its neighbors.
We now describe these phases in detail.
1.In the first phase, the messages µ1,...,µd∈{0,1}∗thatureceives from its neighbors
v1,...,vdare concatenated using the separator #(including a trailing #) and written
onu’s receiving tape. Any previous content is discarded so that the new content of
the receiving tape is the string µ1#···#µd#. In particular, if we are in the first
round, the content is #d, which indicates that uhas not yet received any (nonempty)
messages. In later rounds, µ1,...,µdcorrespond to the messages that were sent by the
neighbors in the previous round, sorted in ascending identifier order. That is, we assume
id(v1)<...< id(vd).
2.In the second phase, u’s copy ofMbehaves like a standard Turing machine with three
tapes. The receiving tape is initialized as stated above, while the sending tape is initially
empty, meaning that any content from the previous round is erased. In case we are in
the first round, the internal tape is initialized to the string λG(u)#id(u)# ¯κ(u), i.e.,
the node gets a copy of its label, identifier, and certificates. Otherwise, the content of
the internal tape remains the same as at the end of the previous round. Now, if the
machine ended up in state qstopin the previous round, then it remains in that state and
immediately goes to phase 3. Otherwise, it starts its local computation in state qstartwith
all three tape heads on the leftmost cell of the tapes, and then goes through a sequence of
computation steps . In each step, depending on the current state and the symbols currently
scanned on the three tapes, the transition function δtellsMhow to update its state and
the symbols on the tapes, and also in which directions to move the three tape heads. The
local computation halts as soon as the machine reaches one of the states qpauseorqstop.
3.In the third phase, the messages µ′
1,...,µ′
d∈{0,1}∗sent to the neighbors v1,...,vd
correspond to the first dbit strings stored on the sending tape, using the symbol #as a
separator and ignoring any □’s. The order of the neighbors is the same as in phase 1, i.e.,
the ascending order of identifiers. In case there are not enough messages on the sending
tape, the missing ones default to the empty string. In particular, if uhas already reached
stateqstopin the previous round, then its sending tape remains empty, so all neighbors
receive an empty message from u.
The execution terminates inr∈N>0rounds if all nodes have reached state qstopby
the end of the r-th round. Note that this implies that the local computations of all nodes
halt in every round. Throughout this paper, we will restrict ourselves to distributed Turing
machines whose executions terminate on every graph under all identifier and certificate-list
assignments.
Result and decision. TheresultM(G,id,¯κ)computed by Mon graphGunder identifier
assignment idand certificate-list assignment ¯κis the graph G′whose nodes and edges are
the same as those of G, and whose labeling function λG′assigns to each node uthe bit string
written on u’s internal tape after M’s execution has terminated. To guarantee that this is
indeed a bit string, any symbols other than 0and1are ignored. In case we do not need any
certificate assignments, we simply write M(G,id)to denote the result computed by MonG
under idand the trivial certificate-list assignment that assigns the empty string to every
node ofG.F. Reiter 19
A distributed Turing machine can act as a consensus-based decision procedure, where all
nodes must agree in order for a given input to be accepted. More precisely, when executing M
onGunder idand¯κ, the individual verdictof nodeu∈Gis the string swith which uis
labeled in the result M(G,id,¯κ). We say that uacceptsinM(G,id,¯κ)ifs= 1, and that
urejectsinM(G,id,¯κ)otherwise. Based on that, Gisaccepted byMunder idand¯κ, written
M(G,id,¯κ)≡accept, if every node accepts in M(G,id,¯κ). Conversely, GisrejectedbyM
under idand¯κif at least one node rejects in M(G,id,¯κ).
Running time. In order to measure the running time of distributed Turing machines, we will
use two different metrics: round time, which corresponds to the number of communication
rounds in an execution, and step time, which gives the number of computation steps made
by a single node in one round.
More precisely, for any execution of a distributed Turing machine M, theround running
timeis the number of rounds until all nodes have reached state qstop. Given some function
f:N→N, we say that Mruns in round time fif the round running time is bounded by f
with respect to the cardinality of the graph on which Mis executed. This means that for
every graph G, every identifier assignment idofG, and every certificate-list assignment ¯κof
(G,id), all nodes of Greach state qstopafter at most f(card(G))rounds in the corresponding
execution of M. Accordingly, Mruns inconstant round time if this holds for some constant
functionf.
On the other hand, the step running time of nodeuin roundi∈N>0of an execution
ofMis the number of local computation steps that umakes during (phase 2 of) round i. For
f:N→N, we say that Mruns in step time fif in every execution, the step running time
of every node uin every round iis bounded by fwith respect to the length of u’s initial
tape contents in round i. This means that if Mstarts in state qstartwith some arbitrary
stringss∈{0,1,#}∗andt∈{0,1,#,□}∗written on its receiving and internal tapes, then
Mreachesqpauseorqstopafter at most f(len(s)+len(t))steps. Accordingly, Mruns in
polynomial step time if this holds for some polynomial function f.
Alocal-polynomial machine is a distributed Turing machine that runs in constant round
time and polynomial step time.
Arbiters and the local-polynomial hierarchy. As explained in Section 2.1, each graph
propertyLin the local-polynomial hierarchy corresponds to a game between two players:
Eve, who tries to prove that a given graph Ghas property L, andAdam, who tries to prove
the opposite. The players take turns labeling the nodes of Gwith certificates, which serve as
proofs (in Eve’s case) and counterproofs (in Adam’s case). After a fixed number ℓof moves,
the winner is determined by a local-polynomial machine M, and the graph Ghas property L
if and only if Eve has a winning strategy in this game. Depending on who makes the first
move,Lis classified as a Σlp
ℓ-property (if Eve starts) or a Πlp
ℓ-property (if Adam starts).
Formally, we represent Eve’s and Adam’s choices by quantifying existentially and univer-
sally, respectively, over the certificate assignments chosen by each player. More precisely,
forℓ∈N, a graph property Lbelongs to Σlp
ℓif there exists a local-polynomial machine M,
constantsrid,r∈N>0, and a polynomial function psuch that the following equivalence holds
for every graph Gand everyrid-locally unique identifier assignment idofG:
G∈L⇐⇒ ∃κ1∀κ2... Qκℓ:M(G,id, κ1·κ2·...·κℓ)≡accept,
where Qis∀ifℓis even and∃otherwise, and all quantifiers range over (r,p)-bounded
certificate assignments of (G,id). We say that MarbitratesLwith respect to Σlp
ℓand call it
aΣlp
ℓ-arbiterforLunderrid-locally unique identifiers and (r,p)-bounded certificates.20 A LOCAL View of the Polynomial Hierarchy
The class Πlp
ℓand the notion of Πlp
ℓ-arbiters are defined analogously, with the only
difference that quantifier alternation starts with a universal quantifier instead of an existential
one. That is, for Πlp
ℓ, we modify the above equivalence to read “ ∀κ1∃κ2... Qκℓ”, where
Qis∃ifℓis even and∀otherwise. We refer to the family of classes {Σlp
ℓ,Πlp
ℓ}ℓ∈Nas the
local-polynomial hierarchy .
Notethatthecertificateassignments κ1,...,κℓmaydependontheidentifierassignment id.
Moreover, the individual verdict of a single node may vary depending on the identifiers and
certificates in its neighborhood. However, G’s membership in L(and thus whether Eve has a
winning strategy) must be independent of the particular identifier assignment.
Two classes at the lowest levels of the hierarchy are of particular interest: LP=Σlp
0
(forlocal-polynomial time ) is the class of graph properties that can be decidedby a local-
polynomial machine, and NLP =Σlp
1(fornondeterministic local-polynomial time ) is the
class of graph properties that can be verifiedby a local-polynomial machine. Accordingly,
Σlp
0-arbiters and Σlp
1-arbiters are also called LP-deciders andNLP-verifiers, respectively.
Complement hierarchy. Thecomplement class of a class Cof graph properties is the class
{¯L|L∈C}, where ¯Ldenotes the complement of a graph property L, i.e., ¯L=graph\L.
Forℓ∈N, we denote the complement classes of Σlp
ℓandΠlp
ℓbycoΣlp
ℓandcoΠlp
ℓ, and
also often denote coΣlp
0andcoΣlp
1bycoLPandcoNLP, respectively. As we shall see
in Corollary 38, classes on the same level of the local-polynomial hierarchy are neither
complement classes of each other, nor are they closed under complementation, so it makes
sense to consider their complement classes in their own right. We will refer to the family of
classes{coΣlp
ℓ,coΠlp
ℓ}ℓ∈Nas thecomplement hierarchy of the local-polynomial hierarchy.
Connection to standard complexity classes. On single-node graphs, distributed Turing
machines are equivalent to standard Turing machines that take as input the label and
certificates of the unique node. The node’s identifier is irrelevant and can therefore be
assumed empty, so the condition of the certificates being (r,p)-bounded reduces to them being
polynomially bounded in the length of the label. Hence, by restricting the classes Σlp
ℓandΠlp
ℓ
tonodeand identifying single-node graphs with strings, we obtain the corresponding classes
Σp
ℓandΠp
ℓof the classical polynomial hierarchy introduced by Meyer and Stockmeyer [ 30] (see,
e.g., [2, §5.2]). In particular, P=LP|node=coLP|nodeandNP=NLP|node=coΠlp
1|node.
5 Logic with bounded quantifiers
We now introduce a logical formalism that will provide a purely syntactic characterization of
most of the complexity classes defined in the previous section. This characterization will be
presented in Section 7.
5.1 Definitions
We begin with the necessary formal definitions, and then illustrate them with a series
of examples in Section 5.2, using standard graph properties such as 3-colorability and
Hamiltonicity. The reader may wish to skip ahead to the examples and refer back to this
subsection as needed.
Variables and interpretations. LetVfobe an infinite supply of first-order variables and
Vso=⋃
k≥1Vso(k)be an infinite supply of second-order variables , also called relation variables ,F. Reiter 21
whereVso(k)contains the second-order variables of aritykandVso(k)∩Vso(k′)=∅fork̸=k′.
We collectively refer to the elements of VfoandVsoasvariables .
Avariable assignment σof a set of variables V⊆V fo∪Vsoon a structure Sis a function
that maps each first-order variable of Vto an element of DSand each second-order variable
ofVto a relation of matching arity over DS. The value σ(R)assigned to a variable Ris
called the interpretation ofRunderσ. We sometimes write σ[R↦→A]to denote the variable
assignment that is identical to σexcept for mapping RtoA. Moreover, if σis irrelevant or
clear from context, we may also omit it to simplify the exposition, and refer directly to Ras
an element or a relation when we really mean σ(R).
Syntax and semantics. To avoid repetitions, we first define the syntax and semantics of
a generalized class of logical formulas, and then specify which particular subclasses we are
interested in.
Table 1 shows how logical formulas , or simply formulas , are built up inductively (in the
first column), and what they mean (in the third column). It also specifies the set free(φ)
of variables that occur freelyin a given formula φ, i.e., outside the scope of any quantifier.
When we need to distinguish between first-order and second-order variables, we use the
notations freefo(φ) =free(φ)∩Vfoandfreeso(φ) =free(φ)∩Vso. Iffree(φ) =∅, thenφis
called asentence.
Table 1Syntax and semantics of all logics considered in this paper.
Syntax Free variables Semantics
FormulaψSetfree(ψ) Necessary and sufficient condition for S,σ|=ψ
1.⊙ix{x} σ(x)∈⊙S
i
2.x⇀iy{x,y} σ(x)⇀S
iσ(y)
3.x.=y{x,y} σ(x) =σ(y)
4.R(x1,...,x k){R,x 1,...,x k}(
σ(x1),...,σ (xk))
∈σ(R)
5.¬φ free(φ) notS,σ|=φ
6.φ1∨φ2 free(φ1)∪free(φ2)S,σ|=φ1orS,σ|=φ2
7.∃xφ free(φ)\{x}S,σ[x↦→a]|=φfor somea∈DS
8.∃x−⇀↽−yφ

where x̸=y{y}∪free(φ)\{x}S,σ[x↦→a]|=φfor somea∈DSs.t.a−⇀↽−Sσ(y)
9.∃Rφ free(φ)\{R}S,σ[R↦→A]|=φfor someA⊆(DS)k
Here,i,k∈N>0,x,x 1,...,x k,y∈V fo,R∈V so(k), andφ,φ 1,φ2are formulas.
The truth of a formula φcan be evaluated on a structure Sof signature (m,n)under a
variable assignment σoffree(φ)onS, provided that φdoes not contain any expressions of
the form⊙ixorx⇀jyfori>mandj >n. Assuming this basic requirement is met, the
third column of Table 1 specifies in which cases Ssatisfiesφunderσ, writtenS,σ|=φ. If
φis a sentence, σis irrelevant, so we simply say that Ssatisfiesφand writeS|=φ. The
property definedby a sentence φon a class of structures Kis the set{S∈K|S|=φ}.
Lines 1 to 4 of Table 1 correspond to atomicformulas. An atomic formula of the form ⊙ix
orx⇀iyrefers to the corresponding set ⊙S
ior binary relation ⇀S
igiven by the structure S,22 A LOCAL View of the Polynomial Hierarchy
while an atomic formula of the form R(x1,...,xk)refers to an additional relation σ(R)given
by the variable assignment σ. Lines 5 and 6 describe the usual Boolean connectives , and
the remaining lines correspond to quantifiers over different scopes: first-order quantification
on lines 7 and 8 ranges over elements, and second-order quantification on line 9 ranges over
relations.
Of particular interest for this paper is the bounded version of first-order quantification
shown on line 8. Intuitively, ∃x−⇀↽−yφcan be read as “there exists an element xconnected to y
such thatφis satisfied”. Here, “connected” means that the elements of Srepresented by x
andyare related by some relation ⇀S
ior its inverse. Thus, bounded first-order quantification
is relative to an already fixed element, represented here by the free variable y.
Syntactic sugar. By nesting bounded first-order quantifiers, we can quantify over elements
that lie within a given distance r∈Nfrom the fixed element. To simplify this, we introduce
the shorthand notation ∃x≤r−−⇀↽−−yφ, which is defined inductively as follows, for any x,y∈Vfo
and formula φ:
∃x≤0−−⇀↽−−yφis equivalent to φ[x↦→y],and
∃x≤r+1− −−−⇀↽−−− −yφis equivalent to ∃x≤r−−⇀↽−−y(
φ∨∃x′−⇀↽−xφ[x↦→x′])
,
whereφ[x↦→y]denotes the formula obtained from φby substituting every free occurrence
ofxbyy, andx′is a fresh first-order variable that does not occur in φ.
For additional convenience, we will make liberal use of truth constants (i.e., ⊥,⊤) and
the remaining operators of predicate logic (i.e., ∧,→,↔,∀), use shorthand notations such as
x̸.=y, andwe may leave out someparentheses, assuming that ∨and∧takeprecedence over →
and↔. Moreover, a sequence consisting solely of existential (∃) or solely of universal (∀)
quantifiers may be combined into a single quantifier that binds a tuple of variables. For
instance, we may write ∀¯Rφinstead of∀R1...∀Rnφ, where ¯R= (R1,...,Rn).
Formulas expressing relations. Given a formula φwith freefo(φ) ={x1,...,xn}, we often
writeφ(x1,...,xn)instead of simply φto convey the intention that φexpresses some
relation between the elements represented by x1,...,xn. If we then want to express that
the same relation holds between some other variables y1,...,ynthat do not occur in the
scope of any quantifier in φ, we writeφ(y1,...,yn)to denote the formula obtained from φ
by simultaneously replacing all free occurrences of x1,...,xnbyy1,...,yn, respectively.
Fragments of first-order logic. For our purposes, the class FOof formulas of first-order
logicis generated by the grammar
φ::=⊙ix|x⇀iy|x.=y|R(x1,...,xk)|¬φ|φ∨φ|∃xφ, (FO)
wherei,k∈N>0,x,x1,...,xk,y∈Vfo, andR∈Vso(k).
The class BFof formulas of the bounded fragment of first-order logic is defined by a
similar grammar, the only difference being that first-order quantification is bounded:
φ::=⊙ix|x⇀iy|x.=y|R(x1,...,xk)|¬φ|φ∨φ|∃x−⇀↽−yφ

wherex̸=y(BF)
To give some basic examples, when evaluated on (the structural representation of) a graph,
the following BF-formulas state that the element represented by the first-order variable xF. Reiter 23
corresponds to a node, to a labeling bit of value 0, and to a labeling bit of value 1, respectively:
IsNode (x) =¬∃y−⇀↽−x(y⇀ 2x) IsBit 0(x) =¬IsNode (x)∧¬⊙ 1x
IsBit 1(x) =¬IsNode (x)∧⊙1x
The first formula is particularly useful, as we will often restrict quantification to nodes.
To simplify this, we introduce the notation ∃◦x φto abbreviate∃x(IsNode (x)∧φ), and
∃◦x≤r−−⇀↽−−yφto abbreviate∃x≤r−−⇀↽−−y(IsNode (x)∧φ), and similarly for universal quantifiers.
Since every BF-formula contains at least one free first-order variable, evaluating such a
formula always requires a variable assignment that provides an element as a “starting point”.
To remedy this, we introduce LFO, the class of formulas of local first-order logic , which are
BF-formulas prefixed by a single universal first-order quantifier. That is, LFOconsists of
formulas of the form ∀xφ, wherex∈Vfoandφ∈BF.
Second-order hierarchies. FOandLFOform the basis of two hierarchies of alternating
second-order quantifiers. The first, called the second-order hierarchy , starts with the base
class Σfo
0=Πfo
0=FO, and continues for ℓ>0with the classes Σfo
ℓandΠfo
ℓthat are obtained
by prepending blocks of existential and universal second-order quantifiers to formulas of Πfo
ℓ−1
andΣfo
ℓ−1, respectively. That is, Σfo
ℓconsists of formulas of the form ∃R1...∃Rnφ, where
R1,...,Rn∈Vsoandφ∈Πfo
ℓ−1, whereas Πfo
ℓconsists of formulas of the form ∀R1...∀Rnφ,
whereφ∈Σfo
ℓ−1.
The other hierarchy, called the local second-order hierarchy , is defined the same way,
except that it starts with the base class LFOinstead of FO. That is, Σlfo
0=Πlfo
0=LFO,
and forℓ>0, the classes Σlfo
ℓandΠlfo
ℓare obtained by prepending blocks of existential and
universal second-order quantifiers to formulas of Πlfo
ℓ−1andΣlfo
ℓ−1, respectively. Notice that it
wouldnotbe equivalent to define Πlfo
ℓas the set of negations of formulas in Σlfo
ℓbecause
LFOis not closed under negation.
As with the local-polynomial hierarchy, it can be helpful to think of formulas of the
(local) second-order hierarchy as a two-player game between EveandAdam, who choose the
existentially and universally quantified relations, respectively. From this point of view, the
referee of the game corresponds to the FO- orLFO-subformula nested inside the second-order
quantifications, and the whole formula is satisfied by the input structure precisely if Eve has
a winning strategy.
Second-order logic is the union of all classes of the second-order hierarchy, and similarly
local second-order logic is the union of all classes of the local second-order hierarchy. The
classes Σfo
1andΣlfo
1will be referred to as the the existential fragments of second-order logic
and local second-order logic, respectively.
Classes of definable properties. For any class of formulas C∈{Σfo
ℓ,Πfo
ℓ,Σlfo
ℓ,Πlfo
ℓ}with
ℓ∈N, we use the corresponding boldface notation C∈{Σfo
ℓ,Πfo
ℓ,Σlfo
ℓ,Πlfo
ℓ}to denote the
class of structure properties that can be defined by a formula of C. It is worth noting that
Σfo
ℓ|node=Σlfo
ℓ|nodeandΠfo
ℓ|node=Πlfo
ℓ|node, since the distinction between bounded and
unbounded quantification is irrelevant on single-node graphs.
5.2 Example formulas
We now show how to express a number of graph properties in local second-order logic,
starting with a very simple property that the nodes can check locally: all-selected , the24 A LOCAL View of the Polynomial Hierarchy
set of labeled graphs in which all nodes are assigned label 1(i.e., they are all “selected”).
▶Example 2. We can easily define all-selected ongraphwith the LFO-formula
∀◦xIsSelected (x), wherexis a first-order variable, and
IsSelected (x) =∃y−⇀↽−x(
IsBit 1(y)∧¬∃z−⇀↽−y(z⇀ 1y∨y⇀ 1z))
is aBF-formula that states that the node represented by xis labeled with the string 1. Here,
the first-order variable yis used to represent x’s unique labeling bit. ⌟
Next, we consider the property of being 3-colorable. Fork∈N>0, the setk-colorable
consists of the graphs Gfor which there exists a function f:VG→[k⟩such thatf(u)̸=f(v)
for all{u,v}∈EG.
▶Example 3. We can define 3-colorable ongraphwith the Σlfo
1-formula
∃C0,C1,C2∀◦xWellColored (x),
whereC0,C1andC2are unary second-order variables intended to represent the sets of nodes
colored with 0,1and2, respectively, xis a first-order variable, and
WellColored (x) =(⋁
i∈[3⟩Ci(x))
∧(⋀
i,j∈[3⟩:i̸=j¬(
Ci(x)∧Cj(x)))
∧∀◦y−⇀↽−x(⋀
i∈[3⟩¬(
Ci(x)∧Ci(y)))
states that the node represented by xis correctly colored. More precisely, the first two
conjuncts express that xis assigned one color and one color only, while the third conjunct
expresses that x’s color is different from its neighbors’ colors. ⌟
To make things a little more challenging, let us now consider the complement of
all-selected , which we denote by not-all-selected . This property is more difficult to
express in local second-order logic. In fact, as we will see in the proof of Proposition 23, it is
notΣlfo
1-definable.
▶Example 4. A straightforward way to define not-all-selected ongraphwould be to
negate the formula from Example 2, yielding the FO-formula∃◦x¬IsSelected (x). But this
formula does not belong to local second-order logic because of the unbounded existential first-
order quantification over x. To remedy this, we can rewrite it as an equivalent Σlfo
3-formula
ExistsUnselectedNode , which intuitively describes the following game: First, Eve tries to
cover the input graph with a spanning forest whose roots include only unselected nodes. She
represents this forest by a binary relation variable P, whereP(x,y)is intended to mean
“the parent of xisy”. If she succeeds, one should thus always reach an unselected node by
following parent pointers. Then, Adam tries to disprove Eve’s claim that Prepresents a
forest by showing that the relation contains a directed cycle. To do so, he chooses a subset X
of nodes, and then asks Eve to assign a charge (positive or negative) to each node such that
roots are positive, children outside Xhave the same charge as their parent, and children in X
have the opposite charge of their parent. Now, if Pis cycle-free, then Eve can charge the
nodes as requested by simply traversing the paths of each tree from top to bottom, starting
with a positive charge at the root, and inverting the charge every time she encounters a
node inX. However, if Pcontains a cycle, then Adam can choose Xto be a singleton set
containing exactly one node of the cycle. By doing so, he prevents Eve from winning because
she will either have to charge the node in Xlike its parent, or charge another node of the
cycle differently than its parent.F. Reiter 25
Formally, we represent the positive and negative charges by a unary relation variable Y
(interpreted as the set of positive nodes), and write
ExistsUnselectedNode =∃P∀X∃Y∀◦x(
PointsTo [¬IsSelected ](x))
.
Here, the subformula PointsTo [¬IsSelected ](x)basically states that x’s parent pointer points
in the direction of an unselected node, assuming that both players play optimally and that
Eve wins the game described above. Since the same idea will be useful later for conditions
other than¬IsSelected (x), we present this subformula as a formula schema that can be
instantiated with any BF-formulaϑ(x):
PointsTo [ϑ](x) = UniqueParent (x)∧RootCase [ϑ](x)∧ChildCase (x),
where
UniqueParent (x) =∃◦y≤1−−⇀↽−−x(
P(x,y)∧∀◦z≤1−−⇀↽−−x(
P(x,z)→z.=y))
states that xhas exactly one parent (possibly itself, in which case it is a root),
RootCase [ϑ](x) =P(x,x)→(
ϑ(x)∧Y(x))
states that if xis a root, then it satisfies the target condition ϑand is positively charged, and
ChildCase (x) =¬P(x,x)→∃◦y−⇀↽−x(
P(x,y)∧(
Y(x)↔¬(Y(y)↔X(x))))
states that if xis a child, then it has the same charge as its parent if it lies outside X, and
the opposite charge of its parent if it belongs to X. ⌟
The spanning-forest construction described in Example 4 can be generalized to express
the complement of any graph property that is definable in local second-order logic. We now
illustratethisusingthecomplementof 3-colorable , whichwedenoteby non- 3-colorable .
As we will show in Corollary 25, this property is not Σlfo
1-definable either.
▶Example 5. To define non- 3-colorable , we could simply negate the formula from Exam-
ple 3, yielding the Πfo
1-formula∀C0,C1,C2∃◦x¬WellColored (x). But just as in Example 4,
this formula does not belong to local second-order logic because of the unbounded existential
first-order quantification over x. Fortunately, the solution is also very similar: we can rewrite
our initial attempt as the equivalent Πlfo
4-formula∀C0,C1,C2ExistsBadNode , using the
subformula
ExistsBadNode =∃P∀X∃Y∀◦x(
PointsTo [¬WellColored ](x))
,
wherePisabinaryrelation, XandYaresets, andthesubformula PointsTo [¬WellColored ](x)
is an instantiation of the formula schema from Example 4. ⌟
Next, we turn to hamiltonian , the property of graphs that contain a Hamiltonian cycle ,
i.e., a cycle that goes through each node exactly once. Again, the spanning-forest construction
from Example 4 proves useful to express this property in local second-order logic.
▶Example 6. We present a Σlfo
5-formula that defines hamiltonian ongraphbased on
the following characterization: a graph is Hamiltonian if and only if it contains a spanning
subgraph (i.e., a subgraph containing all nodes) that is 2-regular (i.e., all nodes have degree 2)
and connected (i.e., any two nodes are linked by a path).26 A LOCAL View of the Polynomial Hierarchy
Intuitively, this property can be tested through the following game: First, Eve chooses a
2-regular spanning subgraph, which she represents by a binary relation H. The intended
meaning of H(x,y)is “the edge{x,y}belongs to the subgraph”. She claims that the chosen
subgraph is a Hamiltonian cycle. Next, Adam tries to disprove this claim by showing that
Eve’s subgraph is disconnected, i.e., that it consists of multiple disjoint cycles. He does this
by choosing a nontrivial subset Sof nodes that he claims form such a cycle. Then, Eve
tries to point out a mistake in Adam’s counterproof. Assuming that she did indeed choose
a Hamiltonian cycle in the first step, there are only two possibilities: either Adam chose a
trivial subset (i.e., the empty set or the set of all nodes), or he partitioned the Hamiltonian
cycle into two nonempty sets of nodes. To tell the nodes which of the two cases applies, Eve
assigns a bit to each of them, represented by a unary relation C. In the first case, represented
by¬C(x), the game is over, and she wins if either all or none of the nodes belong to S.
In the second case, represented by C(x), she must show that there is a discontinuity in
the Hamiltonian cycle, i.e., two adjacent nodes on the cycle that do not agree about their
membership in S. She does this using the technique from Example 4, i.e., by constructing a
spanning forest Pwhose roots witness a discontinuity. Proving the correctness of her forest
adds two more steps to the game, where Adam challenges her with a set Xand she responds
with a setY(see Example 4).
Formally, we define hamiltonian with the Σlfo
5-formula
∃H∀S∃C,P∀X∃Y∀◦x(
DegreeTwo (x)∧ConnectivityTest (x))
,
where
DegreeTwo (x) =∃◦y1,y2−⇀↽−x(
y1̸.=y2∧⋀
i∈{1,2}(
H(x,yi)∧H(yi,x))
∧
∀◦z−⇀↽−x(
H(x,z)∨H(z,x)→⋁
i∈{1,2}(z.=yi)))
statesthatxhasexactlytwoneighborsinthespanningsubgraphrepresentedbytherelation H
(which must be symmetric), and
ConnectivityTest (x) = InAgreementOn [C](x)∧TrivialCase (x)∧PartitionedCase (x)
statesthat, asfaras xcantell, EvehascorrectlypointedoutamistakeinAdam’scounterproof,
sox“believes” Eve’s claim that her subgraph is connected. This belief is correct if it is
shared by all nodes. More precisely, the subformula
InAgreementOn [C](x) =∀◦y−⇀↽−x(
C(x)↔C(y))
ensures that all nodes agree on the type of mistake Adam has made,
TrivialCase (x) =¬C(x)→InAgreementOn [S](x)
covers the case where he has chosen a trivial partition (meaning that all nodes must agree
on whether they belong to S), and
PartitionedCase (x) =C(x)→PointsTo [DiscontinuityAt ](x)
covers the case where Adam’s partition creates a discontinuity in the Hamiltonian cycle.
The subformula PointsTo [DiscontinuityAt ](x)ensures that x’s parent pointer points in the
direction of a discontinuity. It is an instantiation of the formula schema from Example 4
with the BF-formula
DiscontinuityAt (x) =∃◦y−⇀↽−x(
H(x,y)∧(S(x)↔¬S(y)))
,
which states that xand one of its cycle neighbors are on opposite sides of the partition. ⌟F. Reiter 27
Finally, let us adapt Example 6 to define non-hamiltonian , the complement property
ofhamiltonian .
▶Example 7. We essentially reverse the roles of Eve and Adam in the game from Example 6,
but the asymmetric nature of local second-order logic allows us to save one alternation. This
time, Adam starts by proposing a supposed Hamiltonian cycle, and then Eve tries to prove
that his proposition is incorrect. If she is right, there are two possible cases: either Adam
did not propose a 2-regular spanning subgraph, or his subgraph is not connected. Again,
Eve assigns a bit to each node to indicate which of the two cases applies (giving priority
to the first if both apply). In the first case, she constructs a spanning forest whose roots
are nodes at which the 2-regularity condition is violated. In the second case, she chooses a
setScontaining exactly one component of Adam’s subgraph, and then constructs a spanning
forest whose roots witness that Sdoes indeed divide the subgraph into two nonempty parts.
(There must be at least one witness, since we require by definition that the input graph is
connected.)
Reusing the formula schema from Example 4 and some of the subformulas from Example 6,
we can formalize this game as the Πlfo
4-formula
∀H∃C,S,P∀X∃Y∀◦x(
InAgreementOn [C](x)∧InvalidCase (x)∧DisjointCase (x))
,
where
InvalidCase (x) =¬C(x)→PointsTo [¬DegreeTwo ](x)
covers the case where Adam violated the 2-regularity condition, and
DisjointCase (x) =C(x)→¬ DiscontinuityAt (x)∧PointsTo [DivisionAt ](x)
covers the case where his subgraph consists of multiple components. In the latter formula,
the first conjunct ensures that Eve’s partition does not divide any component, while the
second conjunct ensures that her partition is nontrivial, using the subformula
DivisionAt (x) =¬InAgreementOn [S](x),
to state that xsees nodes both inside and outside of S. ⌟
6 Restrictive arbiters
The notion of arbiters defined in Section 4 was kept simple for the sake of presentation, but it
can be cumbersome when constructing arbiters for specific graph properties. In this section,
we provide a more flexible definition that allows us to impose additional restrictions on the
input graphs and certificates. We then prove its equivalence to the original definition.
Certificate restrictors. Letridandrbe positive integers, and pbe a polynomial function. A
certificate restrictor for(r,p)-bounded certificates under rid-locally unique identifiers is a local-
polynomialmachine Mthatsatisfiesthefollowingpropertyforeverygraph G, everyrid-locally
unique identifier assignment idofG, every (r,p)-bounded certificate-list assignment ¯κof
(G,id), and every (r,p)-bounded certificate assignment κof(G,id): if some node u∈G
rejects inM(G,id,¯κ·κ), then there exists an (r,p)-bounded certificate assignment κ′differing
fromκonly in the certificate assigned to usuch thatuaccepts inM(G,id,¯κ·κ′)while the
verdict of all other nodes remains the same as in M(G,id,¯κ·κ). We refer to this property
aslocal repairability . Moreover, we say that MistrivialifM(G,id,¯κ·κ)≡accept for all
choices ofG,id,¯κ,κ.28 A LOCAL View of the Polynomial Hierarchy
Restrictive arbiters. Letℓbe a nonnegative integer, ridandrbe positive integers, pbe
a polynomial function, Kbe an LP-property, and M1,...,Mℓbe certificate restrictors for
(r,p)-bounded certificates under rid-locally unique identifiers. A restrictive Σlp
ℓ-arbiterfor
a graph property LonKunderrid-locally unique identifiers and (r,p)-bounded certifi-
cates restricted by M1,...,Mℓis a local-polynomial machine Mthat satisfies the following
equivalence for every graph G∈Kand everyrid-locally unique identifier assignment idofG:
G∈L⇐⇒ ∃κ1∀κ2... Qκℓ:M(G,id, κ1·κ2·...·κℓ)≡accept,
where Qis∀ifℓisevenand∃otherwise, andallquantifiersrangeover (r,p)-boundedcertificate
assignments of (G,id)with the additional restriction that Mi(G,id, κ1·...·κi)≡accept
for alli∈[1 :ℓ]. If all certificate restrictors are trivial, we say that Moperates under
unrestricted (r,p)-bounded certificates. We analogously define restrictive Πlp
ℓ-arbiters.
Notice that the notion of Σlp
ℓ- and Πlp
ℓ-arbiters for Lintroduced on page 19 coincides
with the notion of restrictive Σlp
ℓ- and Πlp
ℓ-arbiters for Longraphunder unrestricted
certificates. We will refer to such arbiters as permissive arbiters when we want to emphasize
the distinction from other restrictive arbiters. Although not every restrictive arbiter is
permissive, we can prove the following lemma, which allows us to use arbitrary restrictive
arbiters whenever it is more convenient.
▶Lemma 8. Letℓ∈NandK,L⊆graphwithK∈LP. The graph property L∩Kbelongs
toΣlp
ℓ|Kif and only if Lhas a restrictive Σlp
ℓ-arbiter on K. The analogous statement holds
forΠlp
ℓ|K.
Proof.We prove only the first statement, since the proof for Πlp
ℓ|Kis completely analogous.
By definition, if L∩Kbelongs to Σlp
ℓ|K, then there exists a permissive Σlp
ℓ-arbiterMfor a
graph property L′such thatL′∩K=L∩K, and thusMis also a restrictive Σlp
ℓ-arbiter
forLonK.
For the converse, we have to convert an arbitrary restrictive arbiter for LonKinto a
permissive arbiter for some graph property L′such thatL′∩K=L∩K. We do this for
L′=L∩K, proceeding in two steps by first removing the restrictions on the input graphs
and then on the certificates.
LetMabe a restrictive Σlp
ℓ-arbiter for LonKunderra
id-locally unique identifiers and
(ra,pa)-bounded certificates restricted by Ma
1,...,Ma
ℓ.
1.We start by converting Mainto a restrictive Σlp
ℓ-arbiterMbforL∩Kon arbitrary
graphs. Since Kis inLP, there exists an LP-deciderMKfor that property and an integer
rK
id∈N>0suchthatMKoperatesunder rK
id-locallyuniqueidentifiers. Whenexecuting Mb
on a graph Gunder an identifier assignment idand a certificate-list assignment ¯κ, the
nodes first simulate MKto check whether Gbelongs to K. Any node that rejects in
the simulation also immediately rejects in Mb(G,id,¯κ), soGcan only be accepted if it
belongs toK. Then, the nodes that have not rejected simulate Maand return the verdict
reached in that second simulation (unless they learn about some node that has previously
rejected, in which case they also reject). The machine Mbobtained this way operates
on arbitrary graphs under rb
id-locally unique identifiers and (rb,pb)-bounded certificates
restricted by Mb
1,...,Mb
ℓ, whererb
id=max{ra
id, rK
id},rb=ra,pb=pa, andMb
i=Ma
i
fori∈[1 :ℓ].
2.Now we convert Mbinto a permissive Σlp
ℓ-arbiterMcforL∩K. By definition, for every
graphGand everyrb
id-locally unique identifier assignment idofG,
G∈L∩K⇐⇒ ∃κ1∀κ2... Qκℓ:Mb(G,id, κ1·κ2·...·κℓ)≡accept,F. Reiter 29
where all quantifiers range over (rb,pb)-bounded certificate assignments of (G,id)with the
additional restriction that Mb
i(G,id, κ1·...·κi)≡accept for alli∈[1 :ℓ]. The new
machineMchas to satisfy the analogous equivalence without the additional restriction
on the certificate assignments.
When executing MconGunder idandκ1·...·κℓ, the nodes first simulate Mb
1,...,Mb
ℓ
to check if the given certificates satisfy the imposed restrictions. As a result of this first
phase, each node ustores a flag okifor eachi∈[1 :ℓ]to indicate whether uaccepts
inMb
i(G,id, κ1·...·κi). Then, the nodes simulate Mbwhile simultaneously updating
their flags to propagate errors. That is, if a node sees that the okiflag of one of its
neighbors is false, then it also sets its own okiflag to false. Once the simulation of Mb
has terminated, each node ugoessequentially through its flags ok1,..., okℓto verify that
they are all true. If it encounters an okiflag that is false, uaborts, writes a verdict on
its internal tape, and enters state qstop. The verdict depends on whether the certificate
assignment κiis quantified existentially or universally: in the first case, the verdict is 0
(reject), whereas in the second it is 1(accept). Finally, if it did not stop before, ureturns
the same verdict it would have returned when executing Mb.
Note that the sequential verification and early termination described above ensures that
quantifications are relativized in the same way as for Mb. More precisely, if the first
certificate assignment violating the restrictions is quantified existentially, then the input
graph is rejected because all nodes that know about the violation return 0. If instead the
first certificate assignment κiviolating the restrictions of the corresponding machine Mb
iis
quantified universally, then there are two possibilities: either the input graph is accepted
(the desired outcome), or it is rejected because of some node uthat does not know about
the violation. However, in the latter case, there exists an (rb,pb)-bounded certificate
assignment κ′
ithat does not violate the restrictions of Mb
ibut for which ustill rejects.
This is because Mb
isatisfies local repairability, so all defects in κican be fixed without
affectingu. Intuitively speaking, u’s verdict is legitimate since it is independent of the
violation. ◀
7 A generalization of Fagin’s theorem
The founding result of descriptive complexity theory is Fagin’s theorem, which provides a
logical, and thus machine-independent, characterization of the complexity class NP(see,
e.g., [19, Thm. 3.2.4]). In the context of this paper, we can state it as follows.1
▶Theorem 9 (Fagin [ 7]).On single-node graphs, a property can be verified by a local-
polynomial machine if and only if it can be defined by a formula of the existential fragment of
local second-order logic. In symbols, NLP|node=Σlfo
1|node, or equivalently, NP=Σfo
1|node.
The inclusion from right to left is straightforward because any Σfo
1-formula∃R1...∃Rnφ
can be evaluated in polynomial time by a Turing machine that is given some interpretation
ofR1,...,Rn(encoded in the certificate chosen by Eve). The machine can use brute force
1In the literature, Fagin’s theorem is usually stated in terms of arbitrary graphs (or even arbitrary
structures) instead of labeled single-node graphs. More specifically, a graph property can be verified
by a (centralized) Turing machine operating in polynomial time on encodings of graphs if and only
if it can be defined by a formula of the existential fragment of second-order logic. In symbols,
NP|enc(graph )={enc(L)|L∈Σfo
1|graph}, where enc:graph→nodeis some encoding of graphs as
binary strings. However, the statement presented here is equivalent, since it is immaterial whether we
encode graphs as strings or vice versa (see, e.g., Problem 8.4.12 in Papadimitriou’s book [32]).30 A LOCAL View of the Polynomial Hierarchy
to check whether the first-order formula φis satisfied under the given interpretation of
R1,...,Rn, by simply iterating over all possible interpretations of the first-order variables
inφ. The reverse inclusion, however, is more intricate, as it involves encoding the space-time
diagram of a Turing machine by a collection of relations over the input structure. The
key insight that makes this possible is the following: since the machine’s running time is
polynomially bounded by the structure’s cardinality, each cell of the space-time diagram
can be represented by a tuple of elements whose length depends on the degree of the
bounding polynomial.
In this section, we generalize Theorem 9 from single-node graphs to arbitrary graphs,
thereby providing a logical characterization of the complexity class NLP. We then further
generalize this result to obtain similar characterizations of the higher levels of the local-
polynomial hierarchy.
Our proofs make use of the following lemma, which basically states that in the execution of
alocal-polynomialmachine, thespace-timediagramofeachnodeineachroundispolynomially
bounded by the cardinality of a constant-radius neighborhood of the node. For a given
execution of a machine M, thespace usage of nodeuin roundiis the maximum number of
tape cells that uoccupies in round i. More precisely, if we denote by tthe step running time
ofuin roundiand byℓjthe total length of u’s tape contents after its j-th computation step,
thenu’s space usage in round iismax{ℓj|0≤j≤t}.
▶Lemma 10. Letℓandrbe positive integers, pbe a polynomial function, and Mbe a
local-polynomial machine running in round time rand step time p. There exists a polynomial
functionfsuch that the following holds for every labeled graph G, every small r-locally
unique identifier assignment idofG, and all (r,p)-bounded certificate assignments κ1,...,κℓ
of(G,id): in the execution of MonGunder idandκ1·...·κℓ, the step running time and
space usage of each node u∈Gin each round i∈[1 :r]are at most f(
card(N$G
4r(u)))
, i.e.,
fapplied to the number of nodes and labeling bits of u’s4r-neighborhood in G.
Proof.By definition, if idis a smallr-locally unique identifier assignment idofG, then
len(id(u))≤⌈log2card(NG
2r(u))⌉≤⌈ log2card(N$G
2r(u))⌉for every node u∈G. Consider
arbitrary (r,p)-bounded certificate assignments κ1,...,κℓof(G,id), let ¯κ=κ1·...·κℓ,
and let us denote by bi(u)the maximum of u’s step running time and space usage in
roundi∈[1 :r]ofM’s execution on Gunder idand¯κ. Furthermore, for k∈[3r: 4r−1],
let us write nk(u)as a shorthand for card(N$G
k(u)). We now show by induction that for
each round i∈[1 :r], there is a polynomial fi(independent of G,id, and ¯κ) such that
bi(u)≤fi(n3r+i−1(u)).
Assuming node uhasdneighborsv1,...,vd, its initial tape contents in round 1consist
of the string #don its receiving tape and the string λG(u)#id(u)# ¯κ(u)on its internal
tape. Since Mruns in step time p, nodeu’s step running time in round 1cannot exceed
p(
d+len(λG(u) #id(u) # ¯κ(u)))
. This also implies that u’s space usage in round 1, and
thusb1(u), cannot exceed 3·p(
d+len(λG(u) #id(u) # ¯κ(u)))
, since all three tape heads
start on the leftmost cell of their respective tape and can advance by at most one cell
in each computation step. Moreover, we know that d≤n1(u),len(λG(u))≤n0(u),
len(id(u))≤⌈log2n2r(u)⌉, and (since each κiis(r,p)-bounded),
len(¯κ(u))≤ℓ+ℓ·p(∑
v∈NGr(u)len(λG(v) #id(v)))
≤p′(n3r(u)),
wherep′is a polynomial that depends only on ℓandp. The last inequality stems from the
fact that the 2r-neighborhood of any node v∈NG
r(u)is included in u’s3r-neighborhood.F. Reiter 31
We can therefore conclude that b1(u)≤f1(n3r(u))for some polynomial f1that can be easily
derived from p′.
Now, let us assume by induction that there exists a polynomial fisuch thatbi(u)≤
fi(n3r+i−1(u))for every node u∈G. At the beginning of round i+ 1,u’s internal tape
contains a string sof length less than bi(u)and its receiving tape contains a string
of the form µ1#...#µd#, whereµjis a message of length less than bi(vj)that was
sent by neighbor vjin roundi. Again, since we know that Mruns in step time p,
this gives us an upper bound on u’s step running time and space usage: bi+1(u)≤
3·p(
len(s)+len(µ1#...#µd#))
. From the induction hypothesis we obtain that len(s)+
len(µ1#...#µd#)≤d+∑
w∈{u,v1,...vd}fi(n3r+i−1(w)), which cannot exceed n1(u)·(
fi(n3r+i(u)) + 1)
, given that the (3r+i−1)-neighborhood of every neighbor vjofu
is included in u’s(3r+i)-neighborhood. We thus obtain the bound bi+1(u)≤fi+1(n3r+i(u)),
wherefi+1is a polynomial that can be easily derived from pandfi.
Ultimately, we have bi(u)≤fr(n4r−1(u))for alli∈[1 :r], which implies our claim. ◀
We now generalize Fagin’s theorem from NPtoNLP, resulting in the following statement.
Notice that the original result (Theorem 9) can be recovered by restricting both sides of the
equivalence to single-node graphs.
▶Theorem 11. On arbitrary graphs, a property can be verified by a local-polynomial machine
if and only if it can be defined by a formula of the existential fragment of local second-order
logic. In symbols, NLP =Σlfo
1|graph.
As this result will be further generalized below, we do not explicitly prove the backward
direction, which is a simple special case of the backward direction of Theorem 12 on page 35.
However, wedoexplicitlyprovetheforwarddirectiontoprovideamoreaccessibleintroduction
to the general case presented on page 36. The key idea of encoding a space-time diagram
as a collection of relations remains the same as in Fagin’s original proof, but we have to
deal with additional issues such as locally unique identifiers and the exchange of messages
between adjacent nodes.
Proof of Theorem 11 – Forward direction. LetLbe a graph property in NLP, and let
M= (Q,δ)be an NLP-verifier for Lthat operates under rid-locally unique identifiers and
(r1,p1)-bounded certificates, and runs in round time r2and step time p2. Moreover, let
r=max{rid,r1,r2}, and letpbe a polynomial that bounds both p1andp2. By the proof of
Lemma 8, we may assume without loss of generality that Mrejects under any certificate
assignment violating the (r1,p1)-boundedness condition, so it does not matter if Eve chooses
certificates that are too large. Now, we fix k∈Nsuch that the polynomial fdescribed
in Lemma 10 (for ℓ= 1, and our choices of r,p, andM) satisfiesf(n)< nkforn > 1.
By Lemma 10, for every graph Gwhose structural representation has at least two elements,2
every small r-locally unique identifier assignment idofG, and every (r,p)-bounded certificate
assignment κof(G,id), the step running time and space usage of each node u∈Gare
bounded by(
card(N$G
4r(u)))kin each round i∈[1 :r]of the corresponding execution of M.
Intuitively, this gives us a bound on the amount of information required to describe Eve’s
choice of certificates and the subsequent execution of the verifier M, assuming that the nodes
of the input graph are assigned small identifiers. Although our description below does not
2For the single-node graph Gwhose node uis labeled with the empty string, we have (card(N$G
4r(u)))k= 1
for allk∈N, since the structural representation $Ghas only one element. If Gbelongs toL, we can
easily treat it as a special case in the formula φMdescribed here.32 A LOCAL View of the Polynomial Hierarchy
explicitly state this assumption, it may run out of “space” if the provided identifiers are too
large. However, this is not a problem because incomplete executions are simply ignored.
We convert Minto a Σlfo
1-sentence defining Lthat is of the form φM=∃¯R∀◦xψ(x),
where ¯R= (Z,C, ˜C,I0,I1,...)is a collection of second-order variables intended to represent
an accepting execution of M, andψ(x)is aBF-formula stating that, from the point of view of
nodex, the variables in ¯Rdo indeed represent a valid execution of Min whichxaccepts. We
start by introducing the relation variables in ¯R, together with their intended interpretations.
Z: a(2k+ 1)-ary relation that associates with each node xa linear order on the k-tuples
of elements in x’s4r-neighborhood. The intended meaning of Z(x,¯p1,¯p2)is: “fromx’s
point of view, tuple ¯p1is strictly smaller than tuple ¯p2”.
C: a(4k+ 2)-ary relation that establishes a correspondence between the linear orders of
two nodesx1andx2that lie at distance at most 2rof each other. The intended meaning
ofC(x1,¯p1,¯p′
1,x2,¯p2,¯p′
2)is: “The number of steps from ¯p1to¯p′
1in the linear order of x1
is the same as the number of steps from ¯p2to¯p′
2in the linear order of x2”. Or, to put it
more loosely, “ ¯p′
1−¯p1forx1is the same as ¯p′
2−¯p2forx2”.
˜C: a(k+ 2)-ary relation that establishes a correspondence between the linear order of
nodex(defined by Z) and the order of the bits in x’s label (represented by elements of
the input structure). The intended meaning of ˜C(x,z,¯p)is: “the position of bit zinx’s
label corresponds to the position of ¯pinx’s linear order”.
Iα: a family of (k+ 1)-ary relations, for α∈{0,1}, whose purpose is to represent the
r-locally unique identifier of each node x. The intended meaning of Iα(x,¯p)is: “the ¯p-th
bit ofx’s identifier is an α”.
O: a binary order relation that compares, with respect to their identifiers, two nodes x1
andx2that have some common neighbor. The intended meaning of O(x1,x2)is: “x1’s
identifier is smaller than x2’s identifier”.
Kα: a family of (k+ 1)-ary relations, for α∈{0,1}, whose purpose is to represent the
(r,p)-bounded certificate of each node x. The intended meaning of Kα(x,¯p)is: “the ¯p-th
bit ofx’s certificate is an α”.
Si
q: a family of (k+ 1)-ary relations, for i∈[1 :r]andq∈Q, that indicate the state of
each node in every communication round and computation step. The intended meaning
ofSi
q(x,¯t)is: “in round i, at step ¯t, nodexis in stateq”.
Hi
β: a family of (2k+ 1)-ary relations, for i∈[1 :r]andβ∈{rcv,int,snd}, that indicate
the positions of the three tape heads of each node in every communication round and
computation step. The intended meaning of Hi
β(x,¯t,¯p)is: “in round i, at step ¯t, nodex’s
head on tape βis at position ¯p”. Here, we adopt the convention that rcv,int, and snd
refer to the receiving, internal, and sending tapes, respectively.
Ti
β,α: a family of (2k+ 1)-ary relations, for i∈[1 :r],β∈ {rcv,int,snd}, andα∈
{⊢,□,#,0,1}, that indicate the tape contents of each node in every communication
round and computation step. The intended meaning of Ti
β,α(x,¯t,¯p)is: “in round i, at
step ¯t, nodex’s tapeβcontains an αat position ¯p”.
Xi
β: a family of (k+ 2)-ary relations, for i∈[1 :r]andβ∈{rcv,snd}, that indicate
the tape positions of the incoming and outgoing messages that each node exchanges
with its neighbors in every communication round. The intended meaning of Xi
β(x,y,¯p)
is: “in round i, the message exchanged between xandyis written immediately after
position ¯ponx’s tapeβ” (which implies that the symbol at position ¯pis either a⊢or
a#). Forβ=rcv, this corresponds to the incoming message that xreceives from yat
the beginning of round i, whereas for β=snd, this corresponds to the outgoing message
thatxsends toyat the end of round i.F. Reiter 33
It remains to specify the BF-formulaψ(x), which is evaluated from the point of view of
the node represented by the first-order variable x. We define ψas the conjunction of the
following BF-formulas, most of which are described only on an intuitive level to keep the
exposition readable.
LinearTupleOrder (x)states that the relation Zdoes indeed yield a linear order over the
k-tuples inx’s4r-neighborhood, as described above. We can write this formula as follows:
∀¯p1,¯p2,¯p3≤4r+1−−−−⇀↽−−−−x
¬Z(x,¯p1,¯p1)∧(
¯p1̸.= ¯p2→Z(x,¯p1,¯p2)∨Z(x,¯p2,¯p1))
∧(
Z(x,¯p1,¯p2)∧Z(x,¯p2,¯p3)→Z(x,¯p1,¯p3))

The formula “looks” up to distance 4r+1because the labeling bits of a node at distance 4r
lie4r+ 1steps away in the structural representation of the input graph.
Correspondences (x)enforces that the relation Cestablishes the desired correspondence be-
tween the linear order of xand the linear order of every other node in x’s2r-neighborhood,
and that the relation ˜Cestablishes the desired correspondence between the label and
linear order of x. Both properties can be easily specified inductively. For C, the base case
states that C(x,¯p1,¯p1,y,¯p2,¯p2)must hold for every node yinx’s2r-neighborhood and
allk-tuples ¯p1and¯p2in the 4r-neighborhoods of xandy, respectively. The induction
step then states that C(x,¯p1,¯p′
1,y,¯p2,¯p′
2)impliesC(x,¯p1,“¯p′
1+ 1”,y,¯p2,“¯p′
2+ 1”), where
“¯p′
1+ 1” and “ ¯p′
2+ 1” represent the direct successors of ¯p′
1and¯p′
2with respect to xandy,
respectively. For ˜C, the specification is very similar.
UniqueIdentifier (x)ensures that the relations I0andI1represent a binary string for xand
that this string constitutes an r-locally unique identifier. In detail, this means that, with
respect tox, each position ¯pcan be either unlabeled, labeled with 0, or labeled with 1
(but not both). If ¯pis labeled, then so must be its predecessor “ ¯p−1” in the order defined
byZ. Furthermore, for every node yinx’s2r-neighborhood, there exists a position ¯p
at which the labelings of xandydiffer, entailing that x’s identifier is r-locally unique.
In order to refer to “the labeling of yat position ¯p”, we useCto relate ¯pto another
k-tuple ¯p′that represents the same position as ¯pfrom the point of view of node y.
NeighborOrder (x)states that in x’s1-neighborhood, the relation Oagrees with the identifier
order of the nodes. That is, for all neighbors yandzofx, we haveO(y,z)precisely if
the identifier of yis smaller than the identifier of zwith respect to the identifier order.
This is the case if at the first position ¯pwhere the identifiers of yandzdiffer, either y’s
bit is smaller than z’s bit or we have reached the end of y’s identifier while z’s identifier
still goes on. Again, we make use of the correspondence relation Cto relate matching
positions of yandz.
Certificate (x)is very similar to UniqueIdentifier (x). It ensures that the relations K0andK1
represent a certificate of xconsisting of 0’s and 1’s.
ExecGroundRules (x)formalizes some basic properties that any execution of Mmust satisfy
at nodex. In particular, in each round i∈[1 :r], at every step ¯t, the machine must be in
exactly one state q∈Q, there must be exactly one symbol α∈{⊢,□,#,0,1}written at
each position ¯pof each of the three tapes (the symbol of the first position always being ⊢),
and each tape head must be located at exactly one position. Moreover, in each round
there must be some step ¯tat which the machine halts by reaching one of the states qpause
orqstop. Intuitively speaking, xmust respect the basic “mechanics” of Turing machines
and may not run out of space or time (both of which are bounded by the number of
k-tuples inx’s4r-neighborhood).34 A LOCAL View of the Polynomial Hierarchy
OwnInput (x)ensures that at step 0of round 1, nodex’s internal tape contains the string
λG(x)#id(x)#κ(x), whereλG(x)is the label of xthat is represented by the unary
relation⊙$G
1of the input structure $G,id(x)is the identifier of xthat is represented
by the relations I0andI1, andκ(x)is the certificate of xthat is represented by the
relationsK0andK1. To check that λG(x)is written at the beginning of the internal
tape, i.e., just after the left-end marker ⊢, we make use of the relation ˜Cas follows: for
every labeling bit zand every position ¯p, if˜C(x,z,¯p)and IsBitα(z), forα∈{0,1}, then
we must have T1
int,α(x,¯t0,“¯p+ 1”), where ¯t0is the tuple representing computation step 0
and “ ¯p+ 1” denotes the direct successor of ¯p(according to the order defined by Zwith
respect tox). Based on that, the position of the first separator #must bex’s smallest
position ¯ssuch that ˜C(x,z,“¯s−1”)does not hold for any labeling bit z. Next, we check
that the first separator is followed by id(x), using the relation Cto express that id(x)is
shifted by “ ¯s+ 1” positions to the right of the initial position ¯p0: for all positions ¯pand¯p′,
ifC(x,¯p0,¯p,x,“¯s+ 1”,¯p′)andIα(x,¯p), forα∈{0,1}, then we must have T1
int,α(x,¯t0,¯p′).
Finally, we check that the second separator #is followed by κ(x), proceeding completely
analogously with Kαinstead ofIα.
ReceiveMessagesi(x), fori∈[1 :r], states that the messages received by xat the beginning
of roundiare written on x’s receiving tape, each followed by the separator #, and sorted
according to the identifier order of the senders. To accomplish this, the formula also
guarantees by induction that the relation Xi
rcvcorrectly represents the starting positions
of the messages that xreceives from each neighbor.
The base case of the definition of Xi
rcvis straightforward, since the message from x’s
first neighbor y1(with respect to the order relation O) must start immediately after
the left-end marker ⊢onx’s receiving tape. That is, Xi
rcv(x,y1,¯p1), where ¯p1isx’s
first position (with respect to the relation Z).
Now, we need to distinguish two cases. First, suppose that for a given neighbor y,
we haveXi−1
snd(y,x,¯p′)andXi
rcv(x,y,¯p), i.e., the message that ysends toxat the end
of roundi−1is stored right after position ¯p′ony’s sending tape, and the message
thatxreceives from yat the beginning of round iis stored right after position ¯ponx’s
receiving tape. Based on this information, the formula ReceiveMessagesi(x)ensures
that the two messages are indeed the same by stating that on y’s sending tape, at
the end of round i−1, every position ¯s′located between ¯p′and the next occurrence
of#(including the latter position) contains the same symbol as the corresponding
position ¯sonx’s receiving tape at the beginning of round i. (Without loss of generality,
we may assume that the messages on y’s sending tape are always followed by a #and
do not contain any useless □’s.) The fact that position ¯scorresponds to position ¯s′is
expressed by the relation C(x,¯p,¯s,y,¯p′,¯s′), which states that the distance from ¯pto¯s
onx’s receiving tape is the same as the distance from ¯p′to¯s′ony’s sending tape.
The second case is when we have Xi
rcv(x,y,¯p)but there is no ¯p′such thatXi−1
snd(y,x,¯p′).
This means that yhas not written any message for xon its sending tape at the end of
roundi−1, and therefore that xreceives the empty string from yin roundi. (Note
that this happens in particular for i= 1.) In this case, our formula simply states
that at the beginning of round i, the receiving tape of xcontains the separator #at
position “ ¯p+ 1” (which, as before, represents the direct successor of ¯pwith respect
toZ).
Finally, to complete the inductive definition of Xi
rcv, we state that Xi
rcv(x,y,¯p)implies
Xi
rcv(x,z,¯s)ifzis the smallest neighbor of xstrictly greater than y(with respect
toO) and ¯sis the smallest position of xthat is strictly greater than ¯p(with respectF. Reiter 35
toZ) and contains the symbol #. To make sure that the relation Xi
rcvis minimal,
we also require that for every neighbor yofx, there is only one position ¯psuch that
Xi
rcv(x,y,¯p).
InitLocalConfigi(x), fori∈[1 :r], provides the missing parts of the description of x’s local
configuration at time 0in roundi: First, if i≥2, the formula stipulates that the
node’s internal tape contains the same string as at the end of round i−1; fori= 1,
the initial content of the internal tape in round 1has already been specified by the
above formula OwnInput (x). Second, the sending tape must initially be completely
empty. Third, the machine’s state must be reset to qstart, unless it has reached qstopin
roundi−1, in which case the state remains unchanged.
ComputeLocallyi(x), fori∈[1 :r], describes how Mperforms a single computation step
at nodexin roundi. The formula essentially states the following: On the one hand,
for the receiving tape, the cell contents remain the same at all steps ¯t, while for the
internal and sending tapes, the symbol at position ¯premains unchanged between steps ¯t
and “ ¯t+ 1” if the corresponding tape head is not located at position ¯pat step ¯t. On
the other hand, if at step ¯tthe machine is in state qand reads the symbols α1,α2,α3
at positions ¯p1,¯p2,¯p3of the receiving, internal, and sending tapes, respectively, then
the configuration at time “ ¯t+ 1” must take into account the updates specified by the
transition function δ. That is, if δ(q,α1,α2,α3) = (q′,α′
2,α′
3,m1,m2,m3), then at time
“¯t+ 1”„ the machine is in state q′, position ¯p2of the internal tape contains the symbol α′
2,
position ¯p3of the sending tape contains the symbol α′
3, and the three tape heads are
located at positions “ ¯p1+m1”, “¯p2+m2”, and “ ¯p3+m3”.
SendMessagesi(x), fori∈[1 :r], guarantees that the relation Xi
sndcorrectly represents
the starting positions of the messages that xsends to each neighbor at the end of
roundi. Since the inductive definition of Xi
sndis very similar to that of Xi
rcvgiven
inReceiveMessagesi(x), we do not further elaborate on it. Let us only note that in
contrast to Xi
rcv, for some neighbors ythere might be no ¯psuch thatXi
snd(x,y,¯p). This
happens when xdoes not write enough messages on its sending tape for all its neighbors
(in which case the missing messages default to the empty string).
Accept (x)states that xmust eventually reach state qstopin some round i∈[1 :r], with the
string 1written on its internal tape. ◀
Fagin’s theorem was extended by Stockmeyer [ 36] to the higher levels of the polynomial
hierarchy, thus establishing a levelwise correspondence with the second-order hierarchy (see,
e.g., [26, Cor. 9.9]). In the next theorem, we show that this extension also carries over to the
distributed setting. Again, the original result can be recovered by restricting both sides of
the equivalences to single-node graphs.
▶Theorem 12. The local-polynomial hierarchy and the local second-order hierarchy on
graphs are levelwise equivalent from level 1onwards. More precisely, Σlp
ℓ=Σlfo
ℓ|graphand
Πlp
ℓ=Πlfo
ℓ|graphfor allℓ∈N>0.
Proof of Theorem 12 – Backward direction. Let us first assume that we are given a Σlfo
ℓ-
sentenceφ=∃¯R1∀¯R2... Q¯Rℓ∀xψ(x), where each ¯Riis a tuple of second-order variables, and
Qis∀ifℓis even and∃otherwise. Let Lbe the property defined by φon graphs, and let rbe
themaximumnestingdepthofboundedfirst-orderquantifiersinthe BF-formulaψ(intuitively,
the distance up to which ψcan “see”). We construct a restrictive Σlp
ℓ-arbiterMφforLunder
r-locally unique identifiers and (r,p)-bounded certificates restricted by machines M1,...,Mℓ.
Here,pis a polynomial chosen based on the number and arities of the variables in ¯R1,..., ¯Rℓ
such that the certificates described below satisfy the (r,p)-boundedness condition. The36 A LOCAL View of the Polynomial Hierarchy
intention is that for each i∈[1 :ℓ]and each node uof the input graph G, the certificate κi(u)
encodes part of a variable assignment on $Gthat assigns interpretations to the relation
variables in ¯Ri. More precisely, each machine Mirestricts quantification over κisuch that for
each relation variable Rin¯Riof arityk, the certificate κi(u)must encode a set of k-tuples
whose first element represents either uor one of its labeling bits, and whose remaining
elements all represent nodes or labeling bits that lie in the 2r-neighborhood of u. In order to
refer to the elements corresponding to a particular node v, the certificate makes use of v’s
locally unique identifier id(v). Since these additional restrictions on the certificates clearly
satisfy local repairability, Lemma 8 allows us to subsequently convert Mφinto an equivalent
Σlp
ℓ-arbiter without restrictions.
The machine Mφproceeds in r+ 1rounds. In the first rrounds, each node ucollects
information about its r-neighborhood, which allows it to reconstruct NG
r(u)and all the
identifiers and certificates in that subgraph. Then, in the last round, each node uevaluatesψ
locally onN$G
r(u)and accepts if and only if ψis satisfied at the elements representing uand
its labeling bits. Since ψonly makes use of first-order quantification, this can be done in
polynomial time (simply by exhaustive search).
Note that the certificate assignments κ1,...,κℓencode relations ¯R1,..., ¯Rℓon$Gthat
relate only elements whose associated nodes lie at distance at most 2rfrom each other.
However, this does not entail any loss of generality because the formula ψ(which belongs
toBF) can only make statements about elements that lie this close together anyway.
The construction is completely analogous if we are given a Πlfo
ℓ-sentence instead of a
Σlfo
ℓ-sentence. ◀
Proof of Theorem 12 – Forward direction. We start by showing that Σlp
ℓ⊆Σlfo
ℓ|graph.
LetLbe a graph property in Σlp
ℓ, and letMbe aΣlp
ℓ-arbiter for Lthat operates under
rid-locally unique identifiers and (r1,p1)-bounded certificates, and runs in round time r2
and step time p2. Moreover, let r=max{rid,r1,r2}, and letpbe a polynomial that bounds
bothp1andp2. By the proof of Lemma 8, we may assume without loss of generality that
Mrelativizes quantification to certificate assignments that satisfy the (r1,p1)-boundedness
condition, so it does not matter if Eve and Adam choose certificates that are too large.
Now, we fix k∈Nsuch that the polynomial fdescribed in Lemma 10 (for our choices of
ℓ,r,p, andM) satisfiesf(n)< nkforn > 1. By Lemma 10, for every graph Gwhose
structural representation has at least two elements,3every small r-locally unique identifier
assignment idofG, and all (r,p)-bounded certificate assignments κ1,...,κℓof(G,id), the
step running time and space usage of each node u∈Gare bounded by(
card(N$G
4r(u)))k
in each round i∈[1 :r]of the corresponding execution of M. Intuitively, this gives us a
bound on the amount of information required to describe a game between Eve and Adam
and the subsequent execution of the arbiter M, assuming that the nodes of the input graph
are assigned small identifiers.
To convert Minto a Σlfo
ℓ-sentenceφMdefiningL, we use the same relation variables as
in the proof of Theorem 11 (with the same intended interpretations), except that instead
of(K0,K1)we now use (Kj
0,Kj
1)j∈[1 :ℓ]to represent the certificate assignments κ1,...,κℓ.
More precisely, our formula φMis of the form
∃¯Raux∃¯R1∀¯R2... Q¯RℓQ¯Rexe∀◦xψ(x),
3See Footnote 2 in the proof of Theorem 11 (forward direction) on page 31.F. Reiter 37
where Qis∀ifℓis even and∃otherwise, ¯Raux= (Z,C, ˜C,I0,I1,O)is a collection of
auxiliary relation variables that help us specify the remaining relations, I0andI1are
intended to represent an r-locally unique identifier assignment id, each ¯Rjis a pair (Kj
0,Kj
1)
of variables intended to represent a certificate assignment κj(forj∈[1 :ℓ]), and ¯Rexe=
(...,Si
q,...,Hi
β,...,Ti
β,α,...,Xi
β,...)is a collection of variables intended to represent the
execution of Mon the input graph under idandκ1·...·κℓ.
Similarly to the proof of Theorem 11, we would like to state in the BF-formulaψ(x)that
from the point of view of node x, the relations in ¯Raux,¯R1, ..., ¯Rexeare valid in the sense
that they correspond to their intended interpretations. However, in order to relativize all
quantifications to valid relations, we now have to take into account whether a relation is
quantified existentially or universally: ψ(x)must be false if the first invalid relation known
toxis chosen existentially, but true if it is chosen universally. Intuitively speaking, a relation
is invalid from x’s point of view if it does not correctly represent the part of the execution
that affects x(in particular, x’s local computations and the information xreceives from its
neighbors). Unfortunately, this also means that for relations chosen universally, xcannot
simply rely on the fact that other nodes will detect invalidities; if xis affected by an invalidity
within its neighborhood, then it must be “aware” of this itself to ensure that ψ(x)holds
true. Therefore, unlike in the proof of Theorem 11, it is not sufficient for ψ(x)to only check
x’s local computations and message exchanges; it must also check those of the nodes that
have a direct or indirect influence on x. This is very similar to the quantifier relativization
algorithm described in the second part of the proof of Lemma 8.
We now give a formal definition of ψ(x)using the helper formulas LinearTupleOrder (x),
Correspondences (x), and so on, introduced in the proof of Theorem 11. The structure of ψ(x)
depends on the prefix of second-order quantifiers of φM. At the outermost level, ψ(x)checks
that the relations in ¯Rauxare valid from the point of view of all nodes in the r-neighborhood
ofx, using the subformula
ψaux(x) =∀◦y≤r−−⇀↽−−x(
LinearTupleOrder (y)∧Correspondences (y)∧
UniqueIdentifier (y)∧NeighborOrder (y))
.
Since ¯Rauxis quantified existentially, ψaux(x)is used as a conjunct in ψ(x), i.e.,
ψ(x) =ψaux(x)∧ψ1(x).
The second conjunct ψ1(x)checks the validity of the remaining relations, starting with
those in ¯R1. Depending on whether a relation is quantified existentially or universally, its
invalidity makes the remainder of the formula hold false or true, respectively. This leads to
the inductive definition
ψj(x) =

(
∀◦y≤r−−⇀↽−−xCertificatej(y))
→ψj+1(x)ifjis even,
(
∀◦y≤r−−⇀↽−−xCertificatej(y))
∧ψj+1(x)ifjis odd,
forj∈[1 :ℓ], where the helper formula Certificatej(y)is a variant of Certificate (y)that
ensures that the relations Kj
0andKj
1correctly represent a certificate of yconsisting of 0’s
and1’s. For the last formula ψℓ(x), the subformula ψℓ+1(x)is defined below. It checks that
¯Rexeis valid from x’s point of view and that xeventually accepts:
ψℓ+1(x) ={
ψexe(x)→Accept (x)ifℓis even,
ψexe(x)∧Accept (x)ifℓis odd,38 A LOCAL View of the Polynomial Hierarchy
where the formula
ψexe(x) =∀◦y≤r−−⇀↽−−x(
ExecGroundRules (y)∧OwnInput′(y))
∧
⋀
i∈[1 :r]∀◦y≤r−i−−−⇀↽−−−x(
ReceiveMessagesi(y)∧InitLocalConfigi(y)∧
ComputeLocallyi(y)∧SendMessagesi(y))
states that the part of the execution that has an influence on xis correctly represented by
the appropriate relations. (The helper formula OwnInput′(y)is a variant of OwnInput (y)
that takes into account the certificate assignments κ1,...,κℓ.) Sincexis not influenced by
the local computations that nodes at distance imake after round r−i, we only check those
they make between rounds 1andr−i.
To show that Πlp
ℓ⊆Πlfo
ℓ|graph, the construction is almost the same, but the formula φM
is now of the form
∀¯Raux∀¯R1∃¯R2... Q¯RℓQ¯Rexe∀◦xψ(x),
where Qis∃ifℓis even and∀otherwise. Since the auxiliary relation variables in ¯Rauxare
now quantified universally, the subformula ψ(x)becomes
ψ(x) =ψaux(x)→ψ1(x).
Similarly, the roles of even and odd indices are swapped in the definitions of ψj(x), for
j∈[1 :ℓ+ 1], to account for the fact that the quantifier alternation now starts with a block
of universal quantifiers. ◀
8 Hardness and completeness results
Reductions play a fundamental role in classical complexity theory, allowing us to compare
the computational complexities of different problems, even when we are unable to determine
any of them absolutely. Fraigniaud, Korman, and Peleg [ 14] transferred this idea to the
setting of distributed decision, where they introduced the notion of local reductions . A local
reduction from a property Lto a property L′is performed by a distributed algorithm that
modifies the labeling of the input graph in constant round time such that the original graph
has property Lif and only if the relabeled graph has property L′. While this unconstrained
definition turned out to be too strong for the types of certificates considered, Balliu, D’Angelo,
Fraigniaud, and Olivetti [ 3] later refined the concept and used it to establish completeness
results for two classes of their identifier-independent hierarchy. However, they also noted that
the local reductions involved were “very much time consuming at each node” and left as an
open problem “whether non-trivial hardness results can be established under polynomial-time
local reductions”.
In this section, we extend Karp’s [ 22] notion of polynomial-time reductions to computer
networks. Our definition can also be seen as a further refinement of the aforementioned local
reductions, where we impose bounds on the step running time of the algorithms performing
the reductions and additionally require them to work under locally unique identifiers. As a
presentation choice, we consider graph transformations that are slightly more general than
just relabelings. These transformations may implicitly encode parts of the topology of the new
graph in the output computed at each node of the original graph, thus allowing reductions
to more natural graph properties. We then establish several hardness and completeness
results for the two lowest levels of the local-polynomial hierarchy. We start with relativelyF. Reiter 39
simple reductions showing that Eulerianness is LP-complete, while Hamiltonicity is both
LP-hard and coLP-hard. Then, building on Theorem 11, we generalize the Cook–Levin
theorem from NPtoNLP, which gives us a first NLP-complete graph property. Finally,
using standard techniques from complexity theory, we use this property to establish the
NLP-completeness of 3-colorability.
In a way, the framework of reductions proves even more beneficial in the distributed
setting than in the centralized setting. Indeed, since we will prove the infiniteness of the
local-polynomial hierarchy in Section 9, all the hardness and completeness results presented
below immediately yield unconditional lower bounds on the complexity of the properties in
question, i.e., lower bounds that do not rely on any complexity-theoretic assumptions (see
Corollaries 22, 25 and 26 in Section 9.1).
Clusters and implementable functions. Before we can define an appropriate notion of
reduction, we need to generalize the idea of computable functions to our model of computation.
Intuitively, the result M(G,id)computed by a distributed Turing machine Mon a graph G
under an identifier assignment idcan be interpreted as the encoding of a new graph G′.
More precisely, for each node uof the original graph G, the output label computed by uis
taken to encode a subgraph of G′, which we refer to as u’s cluster. Since G′may depend
on the identifiers provided by id, and these are not considered part of the input, we shall
regardMas implementing a “nondeterministic” function f:graph→ 2graphinstead of a
functionf:graph→graph.
Formally, a cluster map from a graph G′to a graph Gis a function g:VG′→VGsuch
that{u,v}∈EG′impliesg(u) =g(v)or{g(u), g(v)}∈EG. With respect to g, thecluster
of any node u∈Gis the induced subgraph of G′whose nodes are mapped to u, including
the labels of those nodes.
Letrid∈N>0. A function f:graph→ 2graphisimplemented by a distributed Turing
machineMunderrid-locally unique identifiers if for every G∈graphand everyrid-locally
unique identifier assignment idofG, the result M(G,id)computed by MonGunder id
represents a graph G′∈f(G)in the following sense: there is a cluster map gfromG′toG
such that the label λM(G,id)(u)computed at each node u∈Gencodesu’s cluster with respect
togand all edges to u’s neighbors’ clusters (i.e., all edges between nodes of u’s cluster and
nodes ofu’s neighbors’ clusters). Note that since the specific graph G′∈f(G)computed
byMmay depend on id, its labels may refer to nodes of Gby their identifiers.
A functionf:graph→ 2graphis calledtopology-preserving if any two graphs G∈graph
andG′∈f(G)are identical except for their labeling, i.e., VG=VG′andEG=EG′.
Reductions, hardness, and completeness. Basically, a local-polynomial reduction from a
propertyLto a property L′is a graph transformation, implementable by a local-polynomial
machine, that turns an input graph Ginto a new graph G′such thatGhas property Lif
and only if G′has property L′. The existence of such a reduction implies that L′is at least
as hard asL, since it allows us to convert a hypothetical decider M′forL′into a decider M
forL, which would work as follows: First, Mwould simulate a machine Mredthat performs
the reduction, thereby transforming GintoG′. Then it would simulate M′onG′, and finally
each node of Gwould accept precisely if all nodes of its cluster did so in the simulation.
More formally, let K,L,L′⊆graph. Alocal-polynomial reduction fromLtoL′onK
is a function f:graph→ 2graphimplementable by a local-polynomial machine such that
for all graphs G∈KandG′∈f(G), we haveG∈Lif and only if G′∈L′. If such a
function exists, we denote this fact by L≤lp
KL′. Given a class Cof graph properties, we40 A LOCAL View of the Polynomial Hierarchy
say thatL′isC-hardonKunder local-polynomial reductions if L≤lp
KL′for allL∈C,
and we say that L′isC-complete onKunder local-polynomial reductions if additionally
L′∈C. Since we will not consider other types of reductions, we usually omit mentioning
“under local-polynomial reductions”, and to avoid specifying Kevery time, we stipulate
that “ C-hard” and “ C-complete” imply K=graphifC∈{Σlp
ℓ,Πlp
ℓ,coΣlp
ℓ,coΠlp
ℓ}ℓ∈N, and
K=nodeifC∈{Σp
ℓ,Πp
ℓ}ℓ∈N.
▶Remark 13. Ifaproperty LisNLP-hard, thenitisalso NP-hard, since node⊆graphand
NP=NLP|node. Moreover, if LisNLP-complete under local-polynomial reductions that
are also topology-preserving, then L∩nodeisNP-complete. This observation generalizes
to all other levels of the local-polynomial and polynomial hierarchies.
In the remainder of this section, we establish a series of hardness and completeness results
for the two lowest levels of the local-polynomial hierarchy. The first is trivial, but will be
useful below. It concerns the property all-selected introduced in Section 5.2.
▶Remark 14. all-selected isLP-complete. This holds even if we impose that all local-
polynomial reductions must be topology-preserving.
Proof.The property obviously lies in LP, and its LP-hardness under topology-preserving
reductions is established by the basic observation that any graph property Ldecided by a
local-polynomial machine Mcan be reduced to all-selected simply by executing M.◁
By considering reductions that do not necessarily preserve the topology of the input
graph, we allow reductions to more natural graph properties. We now illustrate this using
eulerian , the property of graphs that contain an Eulerian cycle , i.e., a cycle that uses each
edge exactly once. The complement of this property will be denoted by non-eulerian .
▶Proposition 15. eulerian isLP-complete.
Proof.By a famous theorem due to Euler (see, e.g., [ 6, Thm. 1.8.1]) a connected graph
is Eulerian if and only if all its nodes have even degree. This characterization makes it
straightforward to decide eulerian with a local-polynomial machine.
To show that the property is also LP-hard, we now describe a local-polynomial reduction
to it from the property all-selected , which is itself LP-complete by Remark 14. Given an
arbitrary graph G, we construct a graph G′whose nodes all have even degree precisely if all
nodes ofGhave label 1. Let us assume without loss of generality that Ghas at least two
nodes. (Single-node graphs can easily be treated as a special case.) For each node u∈VG,
the new graph G′has two copies u0andu1, and for each edge {u,v}∈EG, it contains the
four edges{ui,vj}i,j∈{0,1}. In addition, for each node u∈VGwhose label is not 1, the
new graph also contains the edge {u0,u1}. An example is shown in Figure 7. Notice that
G∈all-selected if and only if G′∈eulerian , thatG′is always connected (as required
by our definition of graphs), and that the nodes of Gcan compute G′in constant round time
and polynomial step time. ◀
WhileitiseasytodetermineifagivengraphisEulerian, itismuchhardertodetermineifit
is Hamiltonian. Indeed, a characterization of hamiltonian similar to Euler’s characterization
ofeulerian is neither known nor expected to exist (see, e.g., [ 6, Ch.10]). The next two
propositions show that this is reflected in the complexity of hamiltonian in our model
of computation: the property is both LP-hard and coLP-hard, which implies that it lies
neither in NLPnor in coNLP (see Corollary 26).F. Reiter 41
cluster ofu cluster ofv cluster ofwG′:u v w1 1 0
G:
Figure 7 Example illustrating the reduction from all-selected toeulerian used in the proof
of Proposition 15. The graph Ghas all node labels equal to 1if and only if the graph G′has an
Eulerian cycle. In this particular case, if node wofGhad label 1, then its cluster in G′would lack
the “vertical” edge, and thus all nodes of G′would have even degree, making G′Eulerian.
cluster ofu1 cluster ofu2
cluster ofu3 cluster ofu4G′:
u1 u2
u3 u41 0
1 1G:
Figure 8 (repeated from Figure 2) Example illustrating the reduction from all-selected
tohamiltonian used in the proof of Proposition 16. The graph Ghas all node labels equal
to1if and only if the graph G′has a Hamiltonian cycle. The thick edges in Gform a spanning tree,
which is replicated by the thick edges in G′. In this particular case, if node u2ofGhad label 1,
then its cluster in G′would lack the “central” node, and thus the thick edges in G′would form a
Hamiltonian cycle.
▶Proposition 16. hamiltonian isLP-hard.
Proof.By Remark 14, it suffices to provide a local-polynomial reduction from all-selected
tohamiltonian . Givenanarbitrarygraph G, weconstructagraph G′thathasaHamiltonian
cycle if and only if all nodes of Ghave label 1. The main idea is that a Hamiltonian cycle
inG′will represent a depth-first traversal of a spanning tree of G, using a method known
as the Euler tour technique. For this purpose, each edge of Gis represented by two edges
inG′, so that it can be traversed twice by a Hamiltonian cycle in G′. More precisely, each
nodeu∈Gof degreedwith neighbors v1,...,vdis represented in G′by a cycle of length
max{3,2d}of the form uv1,u v1,...,u vd,u vd,uv1. For each neighbor viofu, this cycle
contains two adjacent nodes uviandu vi, which can be thought of as the “ports” that
allow us to “go to” and “come from” vi, respectively. (To ensure that there are enough nodes
to form a cycle, we add three dummy nodes if d= 0, and one dummy node if d= 1.) Ifu’s
label differs from 1, thenG′additionally contains a node ubadthat is connected to exactly
one node of the cycle representing u. Moreover, for each edge {u,v}ofG, the graph G′42 A LOCAL View of the Polynomial Hierarchy
contains the two edges {uv,v u}and{u v,vu}. An example is shown in Figure 8.
Now, if all nodes of Gare labeled with 1, then any spanning tree of Gyields a Hamiltonian
cycle ofG′. This cycle includes all edges of G′of the form{u v,uw}withv̸=w,
and additionally, for each edge {u,v}ofG, either the edges {uv,v u}and{u v,vu}if
{u,v}belongs to the spanning tree, and otherwise the edges {uv,u v}and{vu,v u}
(see Figure 8). However, if at least one node uofGhas a label different from 1, thenG′is
not Hamiltonian, because the node ubad, which has degree 1, cannot be part of any cycle.
Hence,G∈all-selected if and only if G′∈hamiltonian .
Notice that G′is guaranteed to be connected (as required by our definition of graphs),
and that the nodes of Gcan compute G′in constant round time and polynomial step time.
As an aside, note that we could reduce the number of nodes of G′by a factor of two by
contracting edges of the form {u v,uw}withv̸=w, but this would make the graphical
representation somewhat less intuitive. ◀
▶Proposition 17. hamiltonian iscoLP-hard.
Proof.By Remark 14 and duality, not-all-selected iscoLP-complete, so it suffices to
provide a local-polynomial reduction from not-all-selected tohamiltonian . In essence,
given any graph G, we use the construction from the proof of Proposition 16 twice to create
two subgraphs G′
topandG′
bot, and then connect them in such a way that the resulting
graphG′has a Hamiltonian cycle if and only if Ghas at least one unselected node (i.e., a
node whose label is not 1). By construction, G′
topandG′
boteach admit a Hamiltonian cycle,
and the presence of an unselected node in Gwill ensure the presence of two edges in G′by
which the two cycles can be connected to form a Hamiltonian cycle of G′. An example is
provided in Figure 9.
More formally, each node u∈Gof degreedis represented in G′by two cycles of length
(2d+ 3), which we will call the “top” and “bottom” cycles. As in the proof of Proposition 16,
for each neighbor vofu, each of the two cycles contains two adjacent nodes, which can be
thought of as the “ports” that allow us to “go to” and “come from” the corresponding cycle
ofv. That is, there are two adjacent nodes utop
vandutop
 vin the “top” cycle of u, which are
connected to the corresponding nodes vtop
uandvtop
 uof the “top” cycle of vby means of the
two edges{utop
v,vtop
 u}and{utop
 v,vtop
u}. The “bottom” cycles are connected by analogous
nodes and edges. Moreover, to ensure that G′is connected (as required by our definition of
graphs), each cycle contains a sequence of three additional nodes, named utop
1,utop
2,utop
3in
the “top” cycle, and ubot
1,ubot
2,ubot
3in the “bottom” cycle. For each node uof the original
graphG, the graph G′contains at least the edge {utop
2,ubot
2}. In addition, if uhas a label
other than 1, thenG′also contains the edge {utop
1,ubot
1}.
Clearly, the new graph G′can be computed in constant round time and polynomial step
time by the nodes of G. To show the correctness of the construction, let G′
topandG′
botbe the
induced subgraphs of G′that contain all “top” cycles and all “bottom” cycles, respectively. By
the same argument as in the proof of Proposition 16, G′
topandG′
boteach have a Hamiltonian
cycle, sayHtopandHbot. Now, if some node uofGhas a label different from 1, then we can
connectHtopandHbotto form a Hamiltonian cycle of G′. This can be achieved by adding
the edges{utop
1,ubot
1}and{utop
2,ubot
2}, and removing the edges {utop
1,utop
2}and{ubot
1,ubot
2}
(see Figure 9). However, if all nodes of Gare labeled with 1, thenG′does not have a
Hamiltonian cycle. To see why, observe that in this case, all nodes of the form utop
1,utop
3,
ubot
1, orubot
3have degree 2. This implies that all edges incident to these nodes must belong
to any hypothetical Hamiltonian cycle HofG′, and hence that none of the edges of the form
{utop
2,ubot
2}can be part of H. Since there are no other edges connecting G′
topandG′
bot, the
cycleHcannot exist. ◀F. Reiter 43
cluster ofu cluster ofv cluster ofwG′:u v w1 1 0
G:
Figure 9 Example illustrating the reduction from not-all-selected tohamiltonian used in
the proof of Proposition 17. The graph Ghas at least one node with a label different from 1if and
only if the graph G′has a Hamiltonian cycle. In this particular case, since node wofGhas label 0,
there is indeed a Hamiltonian cycle in G′, represented by the thick edges. This Hamiltonian cycle
can be thought of as the result of connecting the two “horizontally stretched” cycles (the “top” one
and the “bottom” one), using the two “vertical” edges of w’s cluster. If whad label 1, then one of
these edges would be missing, making it impossible to connect the two cycles.
We now climb up one level in the local-polynomial hierarchy and investigate the notion of
NLP-completeness. Our treatment of centralized computing as a special case of distributed
computing is particularly helpful here, as it allows us to build directly on classical results
from complexity theory. We begin by recalling the Cook–Levin theorem, which concerns the
problem of determining whether a given Boolean formula is satisfiable.
▶Theorem 18 (Cook and Levin [5, 25]) .satisNP-complete.
While this result was discovered a few years before Fagin’s theorem, it can also be obtained
as a simple corollary of the latter (see, e.g., [ 19, Thm. 3.2.6]). In the following, we will show
that this observation extends to the distributed setting by using Theorem 11 to obtain a
generalized version of the Cook–Levin theorem. But first, we need to generalize the Boolean
satisfiability problem to graphs.
Boolean graph satisfiability. ABoolean graph is a graphGwhose nodes are labeled with
(encodings of) Boolean formulas. We call Gsatisfiable if there exists a function valthat
assigns to each node u∈Ga valuation of the Boolean variables occurring in u’s formula
λG(u)such that
val(u)satisfiesλG(u), and
val(u)is consistent with the valuations of u’s neighbors, i.e., val(u)(P) =val(v)(P)for
every neighbor vofuand every Boolean variable Pthat occurs in both λG(u)andλG(v).
We denote the set of all satisfiable Boolean graphs by sat-graph . The standard Boolean
satisfiability problem satis simply the restriction of sat-graph to single-node graphs, i.e.,
sat=sat-graph∩node.
Now we are ready to generalize the Cook–Levin theorem from NPtoNLP. The original
result (Theorem 18) can be recovered by restricting the following statement to single-node
graphs, as noted in Remark 13.44 A LOCAL View of the Polynomial Hierarchy
▶Theorem 19. sat-graph isNLP-complete. This holds even if we impose that all
local-polynomial reductions must be topology-preserving.
Proof.Obviously, sat-graph lies in NLP, since each node can check in one communication
round and polynomial step time whether a given valuation is both locally satisfying and
consistent with the valuations of its neighbors.
It remains to show that sat-graph isNLP-hard, i.e., that L≤lp
graph sat-graph for every
L∈NLP, and to note that the involved local-polynomial reductions are topology-preserving.
By Theorem 11, we know that Lcan be defined by a Σlfo
1-formula∃R1...∃Rn∀xφ(x).
For each graph G∈graph, we now construct a Boolean graph G′such thatG∈Lif
and only if G′∈sat-graph . The nodes and edges of G′are the same as those of G, and
the labeling function λG′assigns to each node u∈Ga Boolean formula φG
uwhich states
that, for a given interpretation of R1, ...,Rn, the BF-formulaφis satisfied at the element
of$Grepresenting uand at all the elements representing u’s labeling bits. To represent
the relations R1, ...,Rn, we introduce Boolean variables of the form PR(a1,...,a k), with the
intended meaning that the tuple of elements (a1,...,ak)∈(D$G)klies in the relation R.
Formally, we set
φG
u=nodeu
τ{x↦→u}(φ)∧u’s labeling bits⋀
a∈(D$G\VG):a−⇀↽−$Guτ{x↦→a}(φ),
where the translation function τσ(ψ)is defined inductively as follows for every BF-formulaψ
and every variable assignment σ: free fo(ψ)→D$G:
Atomic formulas that do not involve a second-order variable are replaced by their truth
value in $G, i.e.,
τσ(⊙1y) ={
⊤ifσ(y)∈⊙$G
1,
⊥otherwise,τσ(y⇀iz) ={
⊤ifσ(y)⇀$G
iσ(z),
⊥otherwise,
τσ(y.=z) ={
⊤ifσ(y) =σ(z),
⊥otherwise,
fori∈{1,2}.
Atomic formulas that involve a second-order variable are replaced by the corresponding
Boolean variable, i.e., τσ(R(y1,...,yk)) =PR(σ(y1),...,σ (yk)).
Boolean connectives are preserved: τσ(¬ψ) =¬τσ(ψ), andτσ(ψ1∨ψ2) =τσ(ψ1)∨τσ(ψ2).
First-order quantification is expressed through a case distinction over all possible variable
assignments, i.e.,
τσ(∃z−⇀↽−yψ) =⋁
a∈$G:a−⇀↽−$Gσ(y)τσ[z↦→a](ψ).
Clearly, every interpretation of a k-ary relation variable Ron$Gcan be translated to
a valuation of the Boolean variables (PR(a1,...,a k))a1,...,a k∈$G, and vice versa. Hence, the
structure $Gsatisfies∃R1...∃Rn∀xφ(x)if and only if there exists a (global) valuation of
all Boolean variables occurring in G′that simultaneously satisfies all the formulas of G′.
The only issue is that a distributed Turing machine would require globally unique
identifiers to compute G′fromG, since the Boolean variables in G′allow to distinguish
between all elements of $G. So instead of G′, we compute an equisatisfiable Boolean graph G′′F. Reiter 45
for which locally unique identifiers suffice. Let rbe the maximum nesting depth of bounded
first-order quantifiers in φ(intuitively, the distance up to which φcan “see”). For a given
(r+ 1)-locally unique identifier assignment idofG, we define G′′as the graph that one
obtains from G′by rewriting all the Boolean formulas in such a way that each node uand
each of its labeling bits are referred to using the identifier id(u). Note that G′′can be
computed from Gin round time (r+ 1)and polynomial step time. (The size of φis constant
with respect to G.) Furthermore, G′′is satisfiable if and only if G′is so, because elements
that share the same identifier are never referred to by the same formula or by two formulas
belonging to adjacent nodes. ◀
While sat-graph itself may not be a particularly natural graph property, we can use it
as a basis for establishing the NLP-completeness of more natural properties, in the same
way that Karp [ 22] used satto prove many other problems NP-complete. Again, this is
made possible by the flexibility of local-polynomial reductions, which do not necessarily have
to be topology-preserving. We now apply this approach to 3-colorability.
▶Theorem 20. 3-colorable isNLP-complete.
Proof sketch. By Example 3 and Theorem 11, the property 3-colorable lies in NLP.
To show that it is also NLP-hard, we first reduce sat-graph to3-sat-graph , the set of
all satisfiable Boolean graphs in which every node is labeled with a 3-cnfformula, i.e.,
a Boolean formula in conjunctive normal form consisting of clauses with at most three
literals. This is straightforward because the standard reduction from satto3-sat(i.e.,
to3-sat-graph∩node) can be trivially generalized: Given a Boolean graph Gand an
identifier assignment idofG, we create an equisatisfiable graph G′by replacing the formula φ
at each node u∈Gby an equisatisfiable 3-cnfformulaφ′whose size is proportional to the
size ofφ. (This can be done using the Tseytin transformation.) The new formula φ′may
contain additional Boolean variables that do not occur in φ, but every satisfying valuation
ofφcan be extended to a satisfying valuation of φ′, and conversely, every satisfying valuation
ofφ′can be restricted to a satisfying valuation of φ. To ensure that the graphs GandG′
are indeed equisatisfiable, we make the new variables’ names depend on the identifier id(u).
Thus, the valuations of adjacent nodes in G′need to be consistent only for the original
variables, not for the newly introduced ones.
Next, we reduce 3-sat-graph to3-colorable , again by generalizing to arbitrary graphs
the corresponding reduction on single-node graphs. The standard reduction from 3-sat
to the string-encoded version of 3-colorable converts any given 3-cnf-formulaφinto a
graphHφ, which we will refer to as a formula gadget. This graph contains two special nodes
called falseandground, two nodes Pand ¯Pfor each variable Poccurring in φ(to represent
the corresponding positive and negative literals), and a small gadget for each clause of φ.
The edges are chosen in such a way that Hφis3-colorable if and only if φis satisfiable.
Moreover, if a 3-coloring exists, then we may assume without loss of generality that false
and groundare colored 0and2, respectively, and each node representing a literal is colored
by that literal’s truth value ( 0for false, and 1for true). For details, see, e.g., [ 17, Prp. 2.27].
We now generalize this construction to arbitrary graphs. An example is provided in
Figure 10. Given a Boolean graph G, we construct a graph G′that is 3-colorable if and
only ifGis satisfiable. For each node u∈Glabeled with a Boolean formula φ, the cluster
representing uinG′contains a copy of the formula gadget Hφ. We denote this copy by Hu
and mark its nodes with a superscript u. To enforce that the formula gadgets of adjacent
clusters are colored consistently, we connect some of their nodes by means of an additional46 A LOCAL View of the Polynomial Hierarchy
gadget. More precisely, for {u,v}∈EG, if we require that two nodes wu∈Huandwv∈Hv
have the same color, then we connect them using the following connector gadget:
wuwv
Note that any valid 3-coloring of the connector gadget has to assign the same color to wu
andwv. Using this, we connect falseutofalsev,groundutogroundv, andPutoPvfor any
Boolean variable Pthat occurs in the formulas of both uandv(see Figure 10). Thereby
we ensure that each color has the same meaning in both formula gadgets and that variables
shared byuandvare assigned the same truth value. Besides, this also ensures that the
graphG′is connected (as required by our definition of graphs), even if some adjacent nodes
ofGdo not share any variables.
Clearly,G′can be computed from Gby a distributed Turing machine in two rounds
and polynomial step time. (In the first round, the nodes send their label and identifier to
their neighbors; in the second round, they perform only local computations.) The cluster
map fromG′toGcan be chosen such that each cluster contains half of the nodes of each
connector gadget attached to it, as shown in Figure 10. ◀
false
ground
P1¯P1P2¯P2P3¯P3clause
gadget
formula
gadgetfalse
ground
P3¯P3P4¯P4P5¯P5clause
gadgetformula
gadget
cluster representing node u cluster representing node vG′:u v P1∨¯P2∨¯P3 P3∨P4∨¯P5 G:
Figure 10 (repeated from Figure 3) Example illustrating the reduction from 3-sat-graph
to3-colorable used in the proof of Theorem 20. The Boolean graph Gis satisfiable if and only if
the graphG′is3-colorable. The labels in the depiction of G′serve explanatory purposes only and
are not part of the graph.
9 Infiniteness of the local-polynomial hierarchy
In this section, we show that the local-polynomial hierarchy does not collapse. Intuitively,
this means that the more alternations we allow between Eve and Adam, the more graph
properties we can express. More precisely, we prove that all inclusions represented by solid
lines in Figure 11 are strict, and that classes represented on the same level are pairwiseF. Reiter 47
LPΣlp
1 Πlp
1Σlp
2 Πlp
2Σlp
3 Πlp
3Σlp
4 Πlp
4Σlp
5 Πlp
5Σlp
6 Πlp
6...
coLPcoΣlp
1 coΠlp
1coΣlp
2 coΠlp
2coΣlp
3 coΠlp
3coΣlp
4 coΠlp
4coΣlp
5 coΠlp
5coΣlp
6 coΠlp
6...
Σlp
1Σlp
2Σlp
3Σlp
4Σlp
5
Σlp
0= =Πlp
0NLP =
coΣlp
0= =coΠlp
0coNLP =
Figure 11 (extended from Figure 1) The local-polynomial hierarchy (left) and its complement
hierarchy (right). The dotted classes on the far right are the same as those on the far left, repeated
for the sake of readability. Only the lowest seven levels are shown, but the pattern extends infinitely.
Each line (whether solid or dashed) indicates an inclusion of the lower class in the higher class.
(This holds by definition for classes in the same hierarchy, and by Proposition 39 and duality for
classes in separate hierarchies.) All inclusions represented by solid lines are proved to be strict,
and classes located on the same level (regardless of which hierarchy) are proved to be pairwise
distinct, even when restricted to graphs of bounded structural degree (by Proposition 21, Theorem 33,
Corollaries 36, 38 and 40, and duality). The inclusions represented by dashed lines are in fact
equalities on graphs of bounded structural degree (by Proposition 35), but this statement is unlikely
to generalize to arbitrary graphs, where it holds if and only if P=coNP(by Remark 37). This
means that from a distributed computing perspective, the classes depicted with thick borders are
the most meaningful.
distinct. For the remaining inclusions, represented by dashed lines, we expect the proof of
strictness to be difficult, since they are equalities if and only if P=coNP.
The picture becomes simpler when restricted to graphs of bounded maximum degree and
label length. On such graphs, the inclusions represented by dashed lines in Figure 11 are
in fact equalities, so the local-polynomial hierarchy boils down to the classes depicted with
thick borders, yielding a strict linear order of the following form:
Πlp
0|graph (∆)⫋Σlp
1|graph (∆)⫋Πlp
2|graph (∆)⫋Σlp
3|graph (∆)⫋...
Here, graph (∆)denotes the set of graphs of ∆-bounded structural degree, for some ∆∈N.
Formally, the structural degree of a nodeuin a graphGis the number of elements that are
connected to uin the graph’s structural representation $G, i.e., card({a∈$G|a−⇀↽−$Gu}).
In other words, u’s structural degree is the sum of its degree and its label length. We say
thatGis of∆-bounded structural degree if the structural degree of every node u∈Gis at
most∆.48 A LOCAL View of the Polynomial Hierarchy
The remainder of this section is organized as follows. In Section 9.1, we separate LP
fromNLPandcoLPby identifying simple graph properties that lie in one class but not the
other. Then, in Section 9.2, we separate all higher levels of the local-polynomial hierarchy
that end with an existential quantifier. Our proof uses an analogous result about monadic
second-order logic on pictures, as well as an automaton model characterizing the existential
fragment of that logic. Finally, the picture is completed in Section 9.3, where we establish
the remaining separations and inclusions shown in Figure 11 and identify graph properties
that lie outside the hierarchy.
9.1 Warming up at ground level
The connection to logic established in Section 7 will be useful for separating the higher levels
of the local-polynomial hierarchy and its complement hierarchy. But since this connection
does not hold for the lowest level, we must use a different approach to separate LPfromNLP
andcoLP. In this subsection, we do so using elementary arguments based on symmetry
breaking and the pigeonhole principle. This also gives us the opportunity to gain a better
intuition for the lower levels of the local-polynomial hierarchy by revisiting the graph
properties presented in Section 5.2 and taking advantage of the hardness and completeness
results established in Section 8.
▶Proposition 21. Some graph properties can be verified but not decided by a local-polynomial
machine, even when restricted to graphs of bounded structural degree. More precisely,
LP|graph (∆)⫋NLP|graph (∆)for all∆≥2, and a fortiori LP⫋NLP.
Proof.The graph property 2-colorable clearly lies in NLP(simply adapt the formula
from Example 3 and apply Theorem 11). In the following, we show that it does not lie in LP,
even when restricted to graphs of 2-bounded structural degree.
Suppose, for the sake of contradiction, that 2-colorable∩graph (2)∈LP|graph (2). By
Lemma 8, this means that there is a restrictive LP-deciderMfor2-colorable ongraph (2).
Assume that Moperates under rid-locally unique identifiers, and consider an unlabeled cycle
graphGwith node set{u1,...,un}such thatnis odd and greater than 2rid. SinceGis
of odd length, it is not 2-colorable. We now construct a new cycle graph G′with node set
{u1,...,un,u′
1,...,u′
n}by “gluing together” two copies of Gas follows:
G:u1u2
un...G′:u1u2
un...
u′
1u′
2u′
n
...
SinceG′is of even length, it is 2-colorable. Given any rid-locally unique identifier assign-
ment idofG, let id′:VG′→{0,1}∗be such that id′(ui) =id′(u′
i) =id(ui)fori∈[1 :n]. As
n≥2rid, the function id′is anrid-locally unique identifier assignment of G′. Moreover, the
verdict ofuiandu′
iinM(G′,id′)is the same as the verdict of uiinM(G,id), because the
tape contents of these nodes are the same in every communication round and computation
step. Hence, MacceptsGif and only if it accepts G′. This contradicts our assumption that
Mis a restrictive LP-decider for 2-colorable ongraph (2), since both GandG′are of
2-bounded structural degree, but only G′is2-colorable. ◀F. Reiter 49
▶Corollary 22. 3-colorable does not lie in LP.
Proof.By Theorem 20, we know that 3-colorable isNLP-hard, and by Proposition 21,
we know that NLP⊈LP. This implies that 3-colorable cannot lie in LP, since otherwise
we could show that NLP⊆LP. To do so, it would suffice to transform a hypothetical
LP-deciderMfor3-colorable into an LP-deciderM′for an arbitrary property L∈NLP.
Thenodesrunning M′wouldfirstapplyalocal-polynomialreductionfrom Lto3-colorable .
Then, each node would simulate Mon its cluster and accept precisely if all nodes of the
cluster do so. (See, e.g., Figure 10 on page 46 for an illustration of two clusters.) ◀
▶Proposition 23. The classes coLPandNLPare incomparable, even when restricted to
graphs of bounded structural degree. More precisely, coLP|graph (∆)⋚NLP|graph (∆)for all
∆≥3, and a fortiori coLP⋚NLP.
Proof.Since not-all-selected lies in coLP(by Remark 14 it is even coLP-complete),
it suffices to show that not-all-selected ∩graph (3)/∈NLP|graph (3). Indeed, this
statement implies that coLP|graph (3)⊈NLP|graph (3), and by duality that LP|graph (3)⊈
coNLP|graph (3), and hence also that NLP|graph (3)⊈coLP|graph (3).
Suppose then, for the sake of contradiction, that not-all-selected ∩graph (3)∈
NLP|graph (3). By Lemma 8, this means that there exists a restrictive NLP-verifierM
fornot-all-selected ongraph (3). Assume that Moperates under rid-locally unique iden-
tifiers and (r1,p)-bounded certificates and runs in round time r2, and letr=max{2rid,r1,r2}.
In the following, we restrict our attention to cycle graphs whose nodes are all labeled with
a single bit and whose length is a multiple of (r+ 1). Notice that on such graphs, we can
construct an rid-locally unique identifier assignment by cyclically assigning each node an
identifier corresponding to a number in [0 :r], encoded as a binary string. If we do so, then the
length of an (r1,p)-bounded certificate is at most m=p(
(2r+1)·(⌈log2r⌉+3))
. Thus, for our
choice of graphs and identifier assignments, there are no more than n= (r+1)·(2m+2−2)2r+1
possible ways to assign labels, identifiers, and certificates to the r2-neighborhood of any node.
First, letGbe a cycle graph whose length is greater than nand a multiple of (r+ 1)
such that exactly one node uhas label 0(the unselected node) and all others have label 1.
Letidbe a cyclic rid-locally unique identifier assignment of Gas described above. Since
G∈not-all-selected ∩graph (3), there exists an (r1,p)-bounded certificate assignment κ
of(G,id)such thatM(G,id,κ)≡accept. By the pigeonhole principle, there must be two
distinct nodes vandv′inGwhoser2-neighborhoods are indistinguishable because the labels,
identifiers, and certificates therein are all the same. Now consider the cycle graph G′obtained
fromGby taking the path between vandv′that does not contain the 0-labeled node u,
and identifying vwithv′. Let id′andκ′be the restrictions of idandκtoG′. Notice that
id′isrid-locally unique, κ′is(r1,p)-bounded, and M(G′,id′,κ′)≡accept because every
node ofG′reaches the same verdict in M(G′,id′,κ′)as inM(G,id,κ). We conclude that
G′∈not-all-selected ∩graph (3), which contradicts the fact that all nodes of G′are
labeled with 1. ◀
▶Corollary 24. The class of graph properties decidable by a local-polynomial machine is not
closed under complementation, even when restricted to graphs of bounded structural degree.
More precisely, LP|graph (∆)̸=coLP|graph (∆)for all∆≥3, and a fortiori LP̸=coLP.
Proof.This follows immediately from Proposition 23. ◀50 A LOCAL View of the Polynomial Hierarchy
▶Corollary 25. non- 3-colorable does not lie in NLP.
Proof.By Theorem 20, we know that 3-colorable isNLP-hard, which by duality means
thatnon- 3-colorable iscoNLP-hard. This implies that non- 3-colorable cannot lie
inNLP, since otherwise we could show that coNLP⊆NLP, contradicting Proposition 23.
The argument is analogous to the proof of Corollary 22, with the additional observation that
a node can simulate an NLP-verifier on its cluster by interpreting its own certificate as an
encoding of the certificates of all nodes of the cluster. ◀
▶Corollary 26. None of the following graph properties lies in NLP:non-eulerian ,
hamiltonian ,non-hamiltonian .
Proof.By the duals of Propositions 15 and 16, and by Proposition 17, all these graph
properties are coLP-hard. Using the same argument as in the proofs of Corollaries 22 and 25,
we conclude from Proposition 23 that none of them lies in NLP. ◀
9.2 Climbing up the hierarchy
We now come to the more technical part of our separation proof, which uses the connection
to logic provided by Theorem 12 to leverage two results about monadic second-order logic
on pictures (stated in Theorems 27 and 29).
Monadic second-order logic is the fragment of second-order logic that can only quantify
over sets instead of arbitrary relations. That is, for second-order quantifications of the form
∃Rφ, the second-order variable Rmust necessarily be of arity 1. We analogously define local
monadic second-order logic as the corresponding fragment of local second-order logic.
Accordingly, the monadic versions of the second-order and local second-order hierarchies
are obtained by restricting second-order quantification in each class to unary relations. To
denote the monadic classes, we add the letter “m” as a prefix to the corresponding non-
monadic classes. This gives us the classes of formulas mΣfo
ℓ,mΠfo
ℓ,mΣlfo
ℓ,mΠlfo
ℓ, forℓ∈N,
and the classes of structure properties mΣfo
ℓ,mΠfo
ℓ,mΣlfo
ℓ,mΠlfo
ℓthat can be defined by
formulas of the respective classes. We will refer to mΣfo
1andmΣlfo
1as the the existential
fragments of monadic second-order logic and local monadic second-order logic.
9.2.1 A digression on pictures
In the context of this paper, pictures are matrices of fixed-length binary strings. More
precisely, for any t∈Nandm,n∈N>0, at-bitpicturePofsize(m,n)is an (m×n)-matrix
whose entries are bit strings of length t. We refer to the positions (i,j)∈⟨m]×⟨n]as
P’spixels. Alternatively, a picture can also be viewed as a function P:⟨m]×⟨n]→{0,1}t.
All the usual terminology of matrices applies; for instance, the pixel (1,1)is referred to as
the top-left corner. The class of all t-bit pictures (of arbitrary size) is denoted by pic(t), and
any subset L⊆pic(t)is called a picture property .
As with graphs, we can evaluate logical formulas on pictures by identifying each t-bit
picturePwith a structure. Formally, the structural representation ofPis the structure
$P= (D$P,⊙$P
1,...,⊙$P
t,⇀$P
1,⇀$P
2)of signature (t,2)with domain D$P=⟨m]×⟨n],
unary relations⊙$P
1,...,⊙$P
t⊆D$Psuch that (i,j)∈⊙$P
kprecisely when the k-th bit of
P(i,j)is1, and “vertical” and “horizontal” successor relations ⇀$P
1,⇀$P
2⊆(D$P×D$P)
such that (i,j)⇀$P
1(i+ 1,j)and(i,j)⇀$P
2(i,j+ 1)for all suitable i,j. An example is
provided in Figure 12.
Monadic second-order logic on pictures has been fairly well-understood since the early
2000s. In particular, Matz, Schweikardt, and Thomas [ 29, Thm. 1] have shown that theF. Reiter 51
00 01 00 01
10 11 10 11
00 01 00 01

P: $P:
Figure 12 (repeated from Figure 5) A2-bit picture Pof size (3,4)and its structural representa-
tion$P. The sets⊙$P
1and⊙$P
2are represented by elements whose left and right halves, respectively,
are colored black, and the relations ⇀$P
1and⇀$P
2are represented by solid and dotted arrows,
respectively.
monadic second-order hierarchy is infinite on several kinds of structures, including pictures.
Here, we state only the part of their result we need, in a stronger form obtained by Matz [ 28,
Thm. 2.26].
▶Theorem 27 (Matz, Schweikardt, Thomas [ 28,29]).The monadic second-order hierarchy
on pictures is infinite. More precisely, mΣfo
ℓ|pic(t)andmΠfo
ℓ|pic(t)are incomparable, which
implies that mΣfo
ℓ|pic(t)⫋mΠfo
ℓ+1|pic(t)andmΠfo
ℓ|pic(t)⫋mΣfo
ℓ+1|pic(t), for allℓ∈N>0and
t∈N.
The ultimate goal of Section 9.2 is to transfer part of Theorem 27 from monadic second-
order logic on pictures to local second-order logic on graphs (and thus to the local-polynomial
hierarchy). This will culminate in Theorem 33 on page 59. As a first milestone towards this
goal, we establish a partial levelwise equivalence between the two logics when restricted to
pictures. We do this in two steps, showing roughly that the expressive power of local second-
order logic on pictures remains unaffected if we first weaken second-order quantification and
then strengthen first-order quantification. The outcome is presented in Theorem 31.
We begin by reducing unrestricted second-order quantification to quantification over sets,
exploiting the fact that local second-order logic on pictures allows us to represent arbitrary
relations as collections of sets.
▶Proposition 28. When restricted to pictures, each level of the local second-order hierarchy
is equivalent to the corresponding level of the local monadic second-order hierarchy. More
precisely, Σlfo
ℓ|pic(t)=mΣlfo
ℓ|pic(t)andΠlfo
ℓ|pic(t)=mΠlfo
ℓ|pic(t)for allℓ,t∈N.
Proof.We only have to show inclusions from left to right, since mΣlfo
ℓis a syntactic fragment
ofΣlfo
ℓ, and mΠlfo
ℓis a syntactic fragment of Πlfo
ℓ. Consider any formula φ∈Σlfo
ℓ∪Πlfo
ℓ, and
letr∈Nbe the maximum nesting depth of bounded first-order quantifiers in φ. Intuitively,
ris the Manhattan distance up to which each pixel can “see” when evaluating φon (the
structural representation of) a picture. Given a picture Pof size (m,n), a Manhattan distance
d∈N, and a pixel (i,j)ofP, we denote by NP
d(i,j)the pixel’s von Neumann neighborhood
of ranged, i.e.,NP
d(i,j)={(i′,j′)∈⟨m]×⟨n]|abs(i′−i)+abs(j′−j)≤d}. We now
show how to use multiple sets of pixels to encode a single relation of arbitrary arity, taking
advantage of the fact that the number of pixels in NP
2r(i,j)is bounded and that each pixel in
this set can be addressed by relative coordinates with respect to (i,j). More precisely, in the
picture’s structural representation $P, each element acan address the elements of NP
2r(a)
using relative coordinate pairs from the finite set C={(∆i,∆j)∈Z2|abs(i)+abs(j)≤2r}.
(The first coordinate gives the “vertical” distance and the second coordinate the “horizontal”
distance with respect to a.) Based on that, if φcontains a second-order variable Rof
arityk≥2, we proceed as follows to represent Rby the collection of unary variables52 A LOCAL View of the Polynomial Hierarchy
(XR(∗,c2,...,ck))c2,...,ck∈C: for any elements a1,...,ak∈$Psuch thata2,...,akbelong to
NP
2r(a1)and are located at positions c2,...,ck∈Cwith respect to a1, we stipulate that a1
lies in the set XR(∗,c2,...,ck)if and only if the tuple (a1,...,ak)lies in the relation R. Notice
that we do not encode the entire relation R, but only its restriction to tuples whose elements
lie within a Manhattan distance of at most 2rfrom the first element a1. This is sufficient for
our purposes, since φcannot refer to any other tuples. (Intuitively, when evaluating φ, each
elementacan only “see” tuples whose elements are all in NP
r(a), so the elements cannot be
further than 2rfrom each other, and in particular from the first element.)
Formally, given r, we define a translation τrfrom local second-order logic to local monadic
second-order logic, proceeding by structural induction:
Atomic formulas that do not involve a relation variable of higher arity are kept unchanged,
i.e.,τr(ψ) =ψifψis of the form⊙ix,x⇀iy,x.=y, orR(x), whereRis of arity 1.
Atomic formulas involving a relation variable Rof arityk≥2are rewritten in terms of
the corresponding unary variables:
τr(
R(x1,...,xk))
=⋁
c2,...,ck∈C(
XR(∗,c2,...,ck)(x1)∧Posc2(x1,x2)∧...∧Posck(x1,xk))
,
where for (∆i,∆j)∈C, the formula Pos(∆i,∆j)(x,y)states that yis located at position
(∆i,∆j)with respect to x. It can be defined inductively as follows:
Pos(∆i,∆j)(x,y) =

∃z−⇀↽−x(
z⇀ 1x∧Pos(∆i+1,∆j)(z,y))
if∆i<0,
∃z−⇀↽−x(
x⇀ 1z∧Pos(∆i−1,∆j)(z,y))
if∆i>0,
∃z−⇀↽−x(
z⇀ 2x∧Pos(∆i,∆j+1)(z,y))
if∆i= 0and∆j<0,
∃z−⇀↽−x(
x⇀ 2z∧Pos(∆i,∆j−1)(z,y))
if∆i= 0and∆j>0,
x.=y if∆i=∆j= 0.
Boolean connectives, first-order quantifiers, and second-order quantifiers over unary
relations are preserved: τr(¬ψ) =¬τr(ψ),τr(ψ1∨ψ2) =τr(ψ1)∨τr(ψ2),τr(∃xψ) =
∃xτr(ψ),τr(∃x−⇀↽−yψ) =∃x−⇀↽−yτr(ψ), andτr(∃Rψ) =∃Rτr(ψ)ifRis of arity 1.
Each second-order quantifier binding a relation variable Rof arityk≥2is replaced
by a collection of second-order quantifiers binding the corresponding unary variables:
τr(∃Rψ) =∃(
XR(∗,c2,...,ck))
c2,...,ck∈Cτr(ψ).
Applying this translation to the initial formula φ, we obtain a formula τr(φ)that is
equivalent to φon pictures. Notice that τrpreserves the alternation level of second-order
quantifiers and that each subformula Pos(∆i,∆j)(x,y)lies in BF. Hence, if φ∈Σlfo
ℓ, then
τr(φ)∈mΣlfo
ℓ, and ifφ∈Πlfo
ℓ, thenτr(φ)∈mΠlfo
ℓ. ◀
Next, we want to strengthen first-order quantification. To do this, we take advantage
of an automaton model for pictures introduced by Giammarresi and Restivo [ 15], which
is closely related to monadic second-order logic. A “machine” in this model, called a t-bit
tiling system , is defined as a tuple T= (Q,Θ), wheretis a nonnegative integer, Qis a finite
set ofstates, andΘ⊆(
({0,1}t×Q)∪{#})4is a set of (2×2)-tiles. Each tile in Θconsists
of entries that are either a t-bit string accompanied by a state in Q, or the special boundary
symbol #(assumed not to be contained in {0,1}t×Q).
At-bit tiling system T= (Q,Θ)operates similarly to a nondeterministic finite automaton
generalized to two dimensions: given a picture P, it first nondeterministically assigns a
state ofQto each pixel of P, and then checks that this assignment of states respects theF. Reiter 53
“transitions” that are allowed by Θ. More precisely, a t-bit picture Pof size (m,n)isaccepted
byTif there exists an assignment ⟨m]×⟨n]→Qsuch that each (2×2)-subblock of P
matches some tile of Θ, assuming that the entire picture is surrounded by a frame consisting
of#’s (to detect the borders), and that a pixel matches (s,q)∈{0,1}t×Qprecisely if its
value issand its assigned state is q. The picture property recognized byTconsists of those
t-bit pictures that are accepted by T. We write TSfor the class of picture properties that
are recognized by some tiling system.
Exploiting a locality property of first-order logic, Giammarresi, Restivo, Seibert, and
Thomas [ 16, Thm. 3.1] have shown that tiling systems capture precisely the nondeterministic
level of the monadic second-order hierarchy on pictures:
▶Theorem 29 (Giammarresi, Restivo, Seibert, Thomas [ 16]).Tiling systems are equivalent
to the existential fragment of monadic second-order logic on pictures. That is, TS|pic(t)=
mΣfo
1|pic(t)for allt∈N.
This result gives us the key to move from bounded to arbitrary first-order quantification.
The following corollary is based on the observation that tiling systems can be easily described
in local monadic second-order logic.
▶Corollary 30. When restricted to pictures, the existential fragment of local monadic second-
order logic is equivalent to the existential fragment of monadic second-order logic. That is,
mΣlfo
1|pic(t)=mΣfo
1|pic(t)for allt∈N.
Proof.Since mΣlfo
1can be seen as a syntactic fragment of mΣfo
1, it suffices to show that
TS|pic(t)⊆mΣlfo
1|pic(t)and then apply Theorem 29. We thus require a translation τfrom
tiling systems to mΣlfo
1-sentences on pictures such that a picture Pis accepted by a tiling
systemTif and only if its structural representation $Psatisfiesτ(T).
By inspecting the proof of Theorem 29 in [ 16, Thm. 3.1], it is easy to see that the
mΣfo
1-sentence provided there can be rewritten as an equivalent mΣlfo
1-sentence, essentially
by replacing unbounded first-order quantifiers with their bounded counterparts. We therefore
only give a high-level description of the construction. For T= (Q,Θ), the formula τ(T)is of
the form
∃(Xq)q∈Q∀x(
OneState (x)∧LegalTiling (x))
,
where each Xqis a unary relation variable intended to represent the set of pixels in state q,
OneState (x)is aBF-formula stating that exactly one state has been assigned to pixel x, and
LegalTiling (x)is another BF-formula stating that each of the (2×2)-subblocks containing
pixelxcorresponds to some tile of Θ. Since the boundary markers #surrounding the picture
are not represented by any elements in the structure $P, the formula LegalTiling (x)performs
a case distinction on whether xlies in one of the four corners, along one of the four borders,
or somewhere else inside the picture. This can be written as a conjunction of the form
LegalTiling (x) =TopLeft (x)∧TopRight (x)∧BottomLeft (x)∧BottomRight (x)∧
Top(x)∧Bottom (x)∧Left(x)∧Right (x)∧Inside (x),
where, for example, the conjunct TopLeft (x)states that if xlies in the top-left corner (i.e.,
if it has neither a “vertical” nor a “horizontal” predecessor), then there must be some tile(# #
#s,q)
∈Θsuch thatxhas valuesand lies in state q. The other conjuncts are similar. ◀
BycombiningProposition28(whichweakenssecond-orderquantification)andCorollary30
(whichstrengthensfirst-orderquantification), wecannowderiveapartiallevelwiseequivalence
between local second-order logic and monadic second-order logic on pictures.54 A LOCAL View of the Polynomial Hierarchy
▶Theorem 31. When restricted to pictures, every level of the local second-order hierarchy
that ends with a block of existential quantifiers is equivalent to the corresponding level of
the monadic second-order hierarchy. That is, Σlfo
ℓ|pic(t)=mΣfo
ℓ|pic(t)ifℓis odd, and
Πlfo
ℓ|pic(t)=mΠfo
ℓ|pic(t)ifℓis even, for all ℓ∈N>0andt∈N.
Proof.We proceed by induction on ℓ. Forℓ= 1, it suffices to apply Proposition 28 and then
Corollary 30, i.e.,
Σlfo
1|pic(t)Prp.28=mΣlfo
1|pic(t)Cor.30=mΣfo
1|pic(t).
Forℓ≥2, let us assume that ℓis even, the other case being completely analogous. We have
Πlfo
ℓ|pic(t)Prp.28=mΠlfo
ℓ|pic(t)=mΠfo
ℓ|pic(t),
by first applying Proposition 28 and then using the fact that mΠlfo
ℓandmΠfo
ℓare defined
in terms of mΣlfo
ℓ−1andmΣfo
ℓ−1, for which the induction hypothesis already provides an
equivalence. More precisely, if ∀X1...∀Xn(φ)is an mΠlfo
ℓ-sentence evaluated on t-bit
pictures, where φstarts with a block of existential quantifiers over sets, then φcan be
evaluated as an mΣlfo
ℓ−1-sentence on (t+n)-bit pictures. The idea is simply to interpret
each atomic formula Xi(x)as⊙t+ix, fori∈[1 :n]. The analogous observation holds for
mΠfo
ℓ-sentences on t-bit pictures, whose subformulas can be interpreted as mΣfo
ℓ−1-sentences
on(t+n)-bit pictures. Since we already know that mΣlfo
ℓ−1|pic(t+n)=mΣfo
ℓ−1|pic(t+n), this
implies that mΠlfo
ℓ|pic(t)=mΠfo
ℓ|pic(t). ◀
9.2.2 From pictures to graphs
With the partial levelwise equivalence obtained in Theorem 31, we can already transfer part
of the separation result of Matz, Schweikardt, and Thomas (Theorem 27) from monadic
second-order logic to local second-order logic, while remaining in the realm of pictures. To
further transfer the result from pictures to graphs, we now show how to encode 0-bit pictures
as graphs of 4-bounded structural degree, and how to translate formulas from one type of
structure to the other.
Thegraph encoding of the 0-bit picture Pof size (m,n)is a graphGPthat represents
each pixel of Pby five nodes: one main node ( pxl), and four auxiliary nodes ( in1,in2,out1,
out2), which can be thought of as the incoming and outgoing “ports” of the pixel. Each main
node is connected to its four ports, and the ports of any adjacent pixels are connected in
such a way as to represent the relations ⇀$P
1and⇀$P
2. Formally, GPis defined by the set
of nodes
VGP=⟨m]×⟨n]×{pxl,in1,in2,out1,out2},
the set of edges
EGP={
{(i,j,pxl),(i,j,α )}⏐⏐i∈⟨m], j∈⟨n], α∈{in1,in2,out1,out2}}
∪{
{(i,j,out1),(i+ 1,j,in1)}⏐⏐i∈⟨m⟩, j∈⟨n]}
∪{
{(i,j,out2),(i,j+ 1,in2)}⏐⏐i∈⟨m], j∈⟨n⟩}
,
and the labeling function
λGP: (i,j,pxl)↦→ε, (i,j,in1)↦→00, (i,j,out1)↦→10,
(i,j,in2)↦→01, (i,j,out2)↦→11,F. Reiter 55
ε ε
ε ε

P: $P:
00
01
1011
00
01
101100
01
1011
00
01
1011GP: $GP:
Figure 13 The0-bit picture Pof size (2,2), its graph encoding GP, and their respective structural
representations $Pand$GP. We follow the same graphical conventions as in Figures 4 and 12.
pxlin1
in2
out1out21
2
1 2
1
21 2
Figure 14 The gadget Gadrepresenting a single pixel whose value is the empty string. Gad
occurs four times in the structure $GPshown in Figure 13. We follow the same graphical conventions
as in Figure 4. The names of the elements serve explanatory purposes only and are not part of
the gadget.56 A LOCAL View of the Polynomial Hierarchy
wherei∈⟨m],j∈⟨n], andεdenotes the empty string. An example is provided in Figure 13.
Notice that GPis always of 4-bounded structural degree.
If we look at the graph encoding’s structural representation $GP(also illustrated in
Figure 13), we see that each pixel is represented by the gadget shown in Figure 14. Formally,
thegadget Gadrepresenting any pixel (i,j)of a0-bit picture Pcorresponds to the structural
representation of the subgraph of GPthat is induced by {i}×{j}×{ pxl,in1,in2,out1,out2}.
It is convenient to identify the domain of Gadwith the set
DGad={pxl,in1,in2,out1,out2}∪(
{in1,in2,out1,out2}×⟨ 2])
,
where the elements in {pxl,in1,in2,out1,out2}represent nodes, and the remaining elements
represent labeling bits. Considering Cartesian products to be associative, this allows us to
identify the domain of the entire structure $GPwith the set of elements D$GP=D$P×DGad,
where the first component specifies the pixel, and the second component specifies the gadget
element.
The following lemma states that the expressive power of the local second-order hierarchy
is basically the same whether we consider pictures or graph encodings of pictures. This is
becausewecantranslateformulasfromonetypeofstructuretotheotherwithoutchangingthe
alternation level of second-order quantifiers. Consequently, any separation result established
for pictures can be transferred to graphs.
▶Lemma 32. Letℓ∈N.
1.For every Σlfo
ℓ-sentenceφevaluated on 0-bit pictures, there is a Σlfo
ℓ-sentenceφ′evaluated
on graphs such that $P|=φif and only if $GP|=φ′for allP∈pic(0).
2.Conversely, for every Σlfo
ℓ-sentenceφevaluated on graphs, there is a Σlfo
ℓ-sentenceφ′
evaluated on 0-bit pictures such that $GP|=φif and only if $P|=φ′for allP∈pic(0).
The analogous statements hold for Πlfo
ℓ-sentences.
Proof.The forward direction (Statement 1) is straightforward. First-order quantification on
$GPis relativized to elements of D$P×{pxl}, which correspond to the central element of the
gadget, and atomic formulas that refer to the relations ⇀$P
1and⇀$P
2of$Pare rewritten in
terms of the representation of these relations in $GP. There is no need to explicitly relativize
second-order quantification, since relations can only be evaluated for elements represented
by first-order variables anyway.
We start by defining some helper formulas. The formula
IsPixel (x) =¬∃y−⇀↽−x(
x⇀ 2y∨y⇀ 2x)
states that xis a “pixel center”, corresponding to element pxlof the gadget. For i∈{1,2},
the formulas
HasBitFalse i(x) =∃y−⇀↽−x(
AtBitPos i(x,y)∧¬⊙ 1y)
and
HasBitTrue i(x) =∃y−⇀↽−x(
AtBitPos i(x,y)∧⊙ 1y)
state that the i-th labeling bit of node xhas value 0and1, respectively, where the subformulas
AtBitPos i(x,y) =

x⇀ 2y∧∃z−⇀↽−x(y⇀ 1z)ifi= 1,
x⇀ 2y∧∃z−⇀↽−x(z⇀ 1y)ifi= 2
identifyyas thei-th labeling bit of x. Building on that,
IsIn 1(x) =HasBitFalse 1(x)∧HasBitFalse 2(x)F. Reiter 57
states thatxis a “vertical input port”, corresponding to element in1of the gadget. Similarly,
we define IsIn 2(x),IsOut 1(x), and IsOut 2(x), which identify the “horizontal input port”,
“vertical output port”, and “horizontal output port”, respectively.
We now show by structural induction that there is a translation τfrom formulas on 0-bit
pictures to formulas on graphs such that for every formula φ, every picture P∈pic(0), and
everyvariableassignment σoffree(φ)on$P, wehave $P,σ|=φifandonlyif $GP,σ′|=τ(φ),
whereσ′is the variable assignment of free(φ)on$GPsuch thatσ′(x) =(
σ(x),pxl)
for all
x∈freefo(φ), and
σ′(R) ={(
(a1,pxl),..., (ak,pxl))⏐⏐(a1,...,ak)∈σ(R)}
for allR∈freeso(φ)of arityk∈N>0.
To express that one pixel of Pis the “vertical” or “horizontal” successor of another, we
state that the appropriate ports of the corresponding nodes of GPare connected, i.e.,
τ(x⇀iy) =∃z1,z2≤2−−⇀↽−−x(
IsOuti(z1)∧IsIni(z2)∧x⇀ 1z1⇀1z2⇀1y)
.
Atomic formulas for equality and other relations are kept unchanged: τ(x.=y) = (x.=y),
andτ(
R(x1,...,xk))
=R(x1,...,xk)for any second-order variable Rof arityk∈N>0.
Boolean connectives are also preserved: τ(¬φ) =¬τ(φ), andτ(φ∨ψ) =τ(φ)∨τ(ψ).
First-order quantifiers are relativized to “pixel centers”. More precisely, the unbounded
universal quantifier at the outermost scope of an LFO-formula is translated by τ(∀xφ) =
∀x(
IsPixel (x)→τ(φ))
. For bounded first-order quantifiers, the idea is the same, but we
have to take into account that two adjoining “pixel centers” lie at a distance of 3from
each other, thus τ(∃y−⇀↽−xφ) =∃y≤3−−⇀↽−−x(
y̸.=x∧IsPixel (y)∧τ(φ))
.
Second-orderquantifiersarenotaffectedbythetranslation, i.e., τ(∃Rφ) =∃Rτ(φ)forany
second-order variable Rof arityk∈N>0. This works because $P,σ|=∃Rφis equivalent
to the existence of A⊆(D$P)ksuch that $P,σ[R↦→A]|=φ, which by induction is
equivalent to the existence of A′⊆(D$P×{pxl})ksuch that $GP,σ′[R↦→A′]|=τ(φ),
whereσ′is defined as above. This in turn is equivalent to the existence of
A′⊆(
D$P×{pxl})kandA′′⊆(
D$GP)k\(
D$P×{pxl})k
such that $GP,σ′[R↦→A′∪A′′]|=τ(φ), whereA′′is irrelevant because we ensure that
all first-order variables refer to “pixel centers”. Finally, since A′∪A′′can be any k-ary
relation on D$GP, the last condition is equivalent to $GP,σ′|=∃Rτ(φ).
Note that our translation preserves the alternation level of second-order quantifiers and
the fact that there is exactly one unbounded universal quantifier nested directly below the
second-order quantifiers. That is, if φis aΣlfo
ℓ- orΠlfo
ℓ-formula, then so is τ(φ). Hence,
Statement 1 corresponds to the special case of the induction hypothesis where φdoes not
have any free variables.
The backward direction (Statement 2) is a bit more tedious because $GPhascard( Gad)
times as many elements as $P. To simulate the additional elements when translating a for-
mulaφfrom graphs to pictures, we introduce a “virtual variable assignment” f: free fo(φ)→
DGadthat tells us for each free first-order variable of φto which element of the gadget it
corresponds. In combination with the actual variable assignment σ′on$P, which tells us the
corresponding pixel, this allows us to reference every element of $GP. Our translation is thus58 A LOCAL View of the Polynomial Hierarchy
parameterized by f. We handle first-order quantification by combining actual quantification
with a case distinction over all possible values of f, and second-order quantification by
representing each k-ary relation variable Rofφby a collection of variables R(a1,...,a k), one
for eachk-tuple (a1,...,ak)of gadget elements.
Formally, we show by structural induction that there is a parameterized translation τf
from formulas on graphs to formulas on 0-bit pictures such that for every formula φ, every
pictureP∈pic(0), and every variable assignment σoffree(φ)on$GP, we have $GP,σ|=φ
if and only if $P,σ′|=τf(φ), whereσ′is the variable assignment of free(φ)on$Pandfis
the “virtual variable assignment” freefo(φ)→DGadsuch thatσ(x) =(
σ′(x),f(x))
for all
x∈freefo(φ), and
σ(R) =⋃
a1,...,a k∈Gad{(
(b1,a1),..., (bk,ak))⏐⏐(b1,...,bk)∈σ′(R(a1,...,a k))}
for allR∈freeso(φ)of arityk∈N>0.
To express that an element of $GPlies in the set⊙$GP
1, we state that the corresponding
pixel of $Pis mapped by fto a gadget element that lies in ⊙Gad
1. Hence,
τf(
⊙1x)
={
⊤iff(x)∈⊙Gad
1,
⊥otherwise.
To express that two elements of $GPare connected by the relation ⇀$GP
i, we need to
distinguish the case where they belong to the same gadget from the case where they are
in two adjacent gadgets. In the first case, the corresponding pixels of $Pmust coincide
and be mapped by fto two gadget elements that are connected by ⇀Gad
i. In the second
case, the connection must necessarily be a “ ⇀1”-link from an “input port” to an “output
port”, or vice versa, and the corresponding pixels of $Pmust be connected accordingly
by the “vertical” or “horizontal” successor relation:
τf(
x⇀iy)
=

x.=yiff(x)⇀Gad
if(y),
x⇀jyifi= 1,f(x) =outj, andf(y) =inj, wherej∈{1,2},
y⇀jxifi= 1,f(x) =inj, andf(y) =outj, wherej∈{1,2},
⊥ otherwise.
In order for two elements of $GPto be equal, they must correspond to the same pixel
of$Pand the same element of the gadget, i.e.,
τf(
x.=y)
={
x.=yiff(x) =f(y),
⊥otherwise.
To express that kelements of $GPareR-related, for some second-order variable Rof
arityk, we state that the corresponding pixels of $Pare related by the appropriate copy
ofR, which is determined by the gadget elements that fassigns to each pixel. That is,
τf(
R(x1,...,xk))
=R(f(x1),...,f(xk))(x1,...,xk).
Boolean connectives are preserved: τf(
¬ψ)
=¬τf(ψ), andτf(
ψ1∨ψ2)
=τf(ψ1)∨τf(ψ2).
First-order quantification over $GPis expressed through a combination of first-order
quantification over $Pand a case distinction over the gadget element to which fmaps
the quantified variable. For the (unique) unbounded first-order quantifier of LFO, this
simply means
τf(
∀xφ)
=∀x⋀
a∈Gadτf[x↦→a](φ).F. Reiter 59
For bounded first-order quantifiers, the case distinction is a bit more involved because we
must take into account the topology of $GP: each element of $GPis connected to its
neighbors within the same gadget, and additionally, an “input” or “output port” is also
connected to its counterpart in the appropriate adjacent gadget. This leads to
τf(
∃y−⇀↽−xφ)
=∃y≤1−−⇀↽−−x(
IntraGadgetφ(x,y)∨InterGadgetφ(x,y))
,
where
IntraGadgetφ(x,y) = (y.=x)∧⋁
a−⇀↽−Gadf(x)τf[y↦→a](φ),
and
InterGadgetφ(x,y) =

y⇀ix∧τf[y↦→outi](φ)iff(x) =ini, fori∈{1,2},
x⇀iy∧τf[y↦→ini](φ)iff(x) =outi, fori∈{1,2},
⊥ otherwise.
Each second-order quantification over $GPis expressed through multiple second-order
quantifications over $P. More precisely, each k-ary relation Aon$GPis represented
as the union of card( Gad)kpairwise disjoint relations such that each relation A(a1,...,a k)
containspreciselythose k-tuplesofAwhosecomponentscorrespondtothegadgetelements
a1,...,ak(in that order). Hence,
τf(
∃Rφ)
=∃(R(a1,...,a k))a1,...,a k∈Gad(
τf(φ))
.
Again, our translation preserves the alternation level of second-order quantifiers and
the fact that there is exactly one unbounded universal quantifier nested directly below the
second-order quantifiers. Hence, Statement 2 corresponds to the special case of the induction
hypothesis where φdoes not have any free variables (which means, in particular, that the
“virtual variable assignment” fis empty). ◀
We now have everything at hand to transfer part of Theorem 27 from monadic second-
order logic on pictures to local second-order logic on graphs, and thus to the local-polynomial
hierarchy. The result is stated in the following theorem and illustrated in Figure 15.
Σlp
ℓ−1 Πlp
ℓ−1Σlp
ℓ Πlp
ℓΣlp
ℓ+1 Πlp
ℓ+1Figure 15 A partial separation result for
the local-polynomial hierarchy obtained in
Theorem 33 for every even integer ℓ≥2.
Each line indicates an inclusion of the lower
class in the higher class. The inclusions rep-
resented by solid lines are proved to be strict,
even when restricted to graphs of bounded
structural degree. This forms the basis for the
fuller separation result shown in Figure 11.
▶Theorem 33. The local-polynomial hierarchy is infinite, even when restricted to graphs
of bounded structural degree. More precisely, Σlp
ℓ−1|graph (∆)⫋Πlp
ℓ|graph (∆)⫋Σlp
ℓ+1|graph (∆),
and a fortiori Σlp
ℓ−1⫋Πlp
ℓ⫋Σlp
ℓ+1, for every even integer ℓ≥2and every integer ∆≥4.60 A LOCAL View of the Polynomial Hierarchy
Proof.By Theorem 12, the statement can be equivalently formulated in terms of the local
second-order hierarchy on graphs: Σlfo
ℓ−1|graph (4)⫋Πlfo
ℓ|graph (4)⫋Σlfo
ℓ+1|graph (4)for every
even integer ℓ≥2. To prove it, we start with the analogous separation result for the monadic
second-order hierarchy on 0-bit pictures, which holds by Theorem 27:
mΣfo
ℓ−1|pic(0)⫋mΠfo
ℓ|pic(0)⫋mΣfo
ℓ+1|pic(0)
By Theorem 31, this can be rewritten in terms of local second-order logic:
Σlfo
ℓ−1|pic(0)⫋Πlfo
ℓ|pic(0)⫋Σlfo
ℓ+1|pic(0) (∗)
We now transfer this result from 0-bit pictures to graphs of 4-bounded structural degree.
The first inequality of (∗)tells us that there exists a picture property L∈Πlfo
ℓ|pic(0)that
does not lie in Σlfo
ℓ−1|pic(0). Applying the forward translation provided by Lemma 32.1 and
the fact that graph encodings of 0-bit pictures are of 4-bounded structural degree, we infer
the existence of a graph property L′∈Πlfo
ℓ|graph (4)such thatP∈Lif and only if GP∈L′,
for every 0-bit picture P. Similarly, the backward translation provided by Lemma 32.2 lets
us deduce that L′/∈Σlfo
ℓ−1|graph (4), because otherwise we would have L∈Σlfo
ℓ−1|pic(0). Hence,
Σlfo
ℓ−1|graph (4)⫋Πlfo
ℓ|graph (4). Analogously, we can conclude from the second inequality
of (∗) that Πlfo
ℓ|graph (4)⫋Σlfo
ℓ+1|graph (4). ◀
9.3 Completing the picture
In this subsection, we establish all the remaining separations and inclusions shown in
Figure 11 on page 47, and then conclude by identifying graph properties that lie outside the
local-polynomial hierarchy.
Our first goal is to prove that the inclusions represented by dashed lines in Figure 11 are
equalities when restricted to graphs of bounded structural degree. To do this, we first show
that on such graphs, we can refine the notion of restrictive arbiters introduced in Section 6
to require that identifier assignments are necessarily small.
Letℓbe a nonnegative integer, ridandrbe positive integers, pbe a polynomial func-
tion,Kbe an LP-property, and M1,...,Mℓbe certificate restrictors for (r,p)-bounded
certificates under rid-locally unique identifiers. A small-restrictive Σlp
ℓ-arbiterfor a graph
propertyLonKunderrid-locally unique identifiers and (r,p)-bounded certificates restricted
byM1,...,Mℓis a local-polynomial machine Mthat satisfies the same equivalence as a
restrictive Σlp
ℓ-arbiter (see on page 28) for every graph G∈Kand every smallrid-locally
unique identifier assignment idofG. That is, the equivalence does not have to hold for
arbitrary-sized identifiers. We analogously define small-restrictive Πlp
ℓ-arbiters.
The following lemma is a refinement of Lemma 8 for small-restrictive arbiters on graphs
of bounded structural degree.
▶Lemma 34. Letℓ,∆∈NandL⊆graph. The graph property L∩graph (∆)belongs
toΣlp
ℓ|graph (∆)if and only if Lhas a small-restrictive Σlp
ℓ-arbiter on graph (∆). The
analogous statement holds for Πlp
ℓ|graph (∆).
Proof.We prove only the first statement, since the proof for Πlp
ℓ|graph (∆)is completely
analogous. By definition, if L∩graph (∆)belongs to Σlp
ℓ|graph (∆), then there exists a
permissive Σlp
ℓ-arbiterMfor a graph property L′such thatL′∩graph (∆)=L∩graph (∆),
and thusMis also a small-restrictive Σlp
ℓ-arbiter for Longraph (∆)under unrestricted
certificates.F. Reiter 61
For the converse, since graph (∆)is anLP-property, it suffices by Lemma 8 to convert
a small-restrictive arbiter into a restrictive arbiter that operates under arbitrary-sized
identifiers. Let Mbe a small-restrictive Σlp
ℓ-arbiter for Longraph (∆)underrid-locally
unique identifiers and (r,p)-bounded certificates restricted by M1,...,Mℓ. We need to
distinguish two cases:
1.Ifℓ= 0, thenMis in fact a small-restrictive LP-decider for Longraph (∆). This means
that every node reaches its verdict simply by examining a portion of the input graph, i.e.,
without having to consider any certificates that could potentially depend on a particular
choice of identifiers. Suppose that Mruns in round time t. We construct M′such that
when it is executed on a graph G, the nodes first communicate for (t+ 2rid)rounds to
reconstruct their (t+ 2rid)-neighborhoods. Then, each node usimulatesMlocally on its
t-neighborhood under every possible small rid-locally unique identifier assignment of G
restricted to NG
t(u), and finally accepts if it did so in every simulation. The condition of
being small rid-locally unique can be respected because uknows the 2rid-neighborhood of
every node in NG
t(u). Note that by running the simulation under every possible identifier
assignment, we avoid the problem of the nodes having to agree on a particular one.
This can be done in constant step time because the restriction to graphs of ∆-bounded
structural degree entails a constant upper bound on the number of (partial) identifier
assignments each node has to consider. The machine M′obtained this way is a restrictive
LP-decider for Longraph (∆)under arbitrary-sized r′
id-locally unique identifiers, where
r′
id=t+ 2rid.
2.Ifℓ > 0, thenMcan be simulated by a machine M′that uses the first certificate
assignment to encode small identifiers. More precisely, let the given small-restrictive
arbiterMbe such that for every graph G∈graph (∆)and every small rid-locally unique
identifier assignment idofG,
G∈L⇐⇒ ∃κ1∀κ2... Qκℓ:M(G,id, κ1·κ2·...·κℓ)≡accept,
where all quantifiers range over (r,p)-bounded certificate assignments of (G,id)with
the additional restriction that Mi(G,id, κ1·...·κi)≡accept for alli∈[1 :ℓ]. We
now construct M′with appropriately chosen constants r′
id,r′∈N>0, polynomial p′, and
certificate restrictors M′
1,...,M′
ℓsuch that for every graph G∈graph (∆)and every
arbitrary-sized r′
id-locally unique identifier assignment id′ofG,
G∈L⇐⇒ ∃κ′
1∀κ2... Qκℓ:M′(G,id′, κ′
1·κ2·...·κℓ)≡accept,
where all quantifiers range over (r′,p′)-bounded certificate assignments of (G,id′)with
the additional restriction that M′
i(G,id′, κ′
1·κ2·...·κi)≡accept for alli∈[1 :ℓ].
The certificate restrictors are chosen such that κ′
1encodes both a small rid-locally unique
identifier assignment idofGand an (r,p)-bounded certificate assignment κ1of(G,id)
satisfying the restrictions imposed by M1, and the remaining certificate assignments
κ2,...,κℓare(r,p)-bounded with respect to (G,id)and satisfy the restrictions imposed
byM2,...,Mℓ. The machine M′itself then simply simulates MonGunder idand
κ1·κ2·...·κℓ.
Note that it is easy to construct M′
1,...,M′
ℓsuch that they satisfy local repairability (and
thus the definition of a certificate restrictor). In particular, the restriction of idbeing small
rid-locally unique is compatible with local repairability because if a node has an invalid
identifier (i.e., too large or not rid-locally unique), then by the proof of Remark 1, we can
assign it a valid identifier without affecting the validity of the other nodes’ identifiers.
Also note that we need the restriction to graphs of ∆-bounded structural degree only for
the caseℓ= 0, not for the case ℓ>0. ◀62 A LOCAL View of the Polynomial Hierarchy
Using the notion of small-restrictive arbiters, we now show that on graphs of bounded
structural degree, it is useless to let Adam choose the last certificate assignment. Intuitively,
this is because on such graphs, the step running time of the nodes can be arbitrarily large
with respect to their local input and the messages they receive, so they can use brute force to
perform universal quantification over the last certificate. This is analogous to the observation
made by Feuilloley, Fraigniaud, and Hirvonen [ 10] for their alternation hierarchy (which does
not impose any restrictions on the processing power of the nodes).
▶Proposition 35. When restricted to graphs of bounded structural degree, every level of
the local-polynomial hierarchy that ends with a universal quantifier is equivalent to the level
directly below it that lacks that final quantifier. Formally, Σlp
ℓ|graph (∆)=Σlp
ℓ+1|graph (∆)ifℓis
odd, and Πlp
ℓ|graph (∆)=Πlp
ℓ+1|graph (∆)ifℓis even, for all ℓ,∆∈N.
Proof.We prove only the second equality, the proof of the first being completely analogous.
LetLbe a graph property in Πlp
ℓ+1|graph (∆), and letMbe a restrictive Πlp
ℓ+1-arbiter for L
ongraph (∆)underrid-locally unique identifiers and unrestricted (r,p)-bounded certifi-
cates. By definition, for every graph G∈graph (∆)and everyrid-locally unique identifier
assignment idofG, we have
G∈L⇐⇒ ∀κ1∃κ2...∀κℓ+1:M(G,id, κ1·κ2·...·κℓ+1)≡accept,
where all quantifiers range over (r,p)-bounded certificate assignments of (G,id). Now,
to show that L∈Πlp
ℓ|graph (∆), it suffices by Lemma 34 to provide a small-restrictive
Πlp
ℓ-arbiterM′forLongraph (∆). More precisely, we construct M′with an appropriately
chosen constant r′
idsuch that for every graph G∈graph (∆)and every small r′
id-locally
unique identifier assignment idofG, we have
G∈L⇐⇒ ∀κ1∃κ2...∃κℓ:M′(G,id, κ1·κ2·...·κℓ)≡accept,
where all quantifiers range over (r,p)-bounded certificate assignments of (G,id).
Given the certificates assigned to them by κ1,...,κℓ, the nodes running M′simulateM
for every possible choice of κℓ+1. To do so, they first communicate for r′=rM+rrounds,
whererMis a (constant) bound on the round running time of M. Settingr′
id=r′, this
allows each node uofGto reconstruct its r′-neighborhood NG
r′(u)and the identifiers and
certificates of all nodes therein. Then, usimulatesMlocally for every (r,p)-bounded
certificate assignment κℓ+1of(G,id)restricted to NG
rM(u). Note that ucan respect the
condition of (r,p)-boundedness because it knows the r-neighborhood of every node in NG
rM(u).
Finally,uaccepts precisely if it has accepted in every simulation.
Intuitively, the reason why this approach works is that there is a universal quantification
on bothκℓ+1and on the nodes in the acceptance criterion of distributed Turing machines.
Therefore, we can reverse the order of quantification (by letting the nodes perform the
quantification over κℓ+1) without changing the semantics.
The step running time of M′atuis clearly exponential in
∑
v∈NG
rM(u)p(∑
w∈NG
r(v)1 + len(λG(w)) + len( id(w)))
.
However, since we require Gto be of∆-bounded structural degree and idto be small
r′-locally unique, this value is bounded by a constant that depends only on ∆,r′, andp.
Hence,M′runs in constant and thus polynomial step time. ◀F. Reiter 63
The equalities established in Proposition 35 not only simplify the local-polynomial
hierarchy on graphs of bounded structural degree, but also imply, in combination with the
previous separation results, that the remaining inclusions in the hierarchy are strict. This is
particularly relevant on arbitrary graphs.
▶Corollary 36. The separation results for the local-polynomial hierarchy stated in Propo-
sition 21 and Theorem 33 can be extended as follows: Πlp
ℓ−1⫋Πlp
ℓ, and Σlp
ℓ⫋Σlp
ℓ+1, and
Πlp
ℓ−1⫋Σlp
ℓ⫋Πlp
ℓ+1, for every even integer ℓ≥2.
Proof.By Proposition 21 and Theorem 33 (for the inequalities), and by Proposition 35 (for
the equalities), we have
Πlp
ℓ−2|graph (4)⫋Σlp
ℓ−1|graph (4)⫋Πlp
ℓ|graph (4)⫋Σlp
ℓ+1|graph (4)=
=
=
Πlp
ℓ−1|graph (4) Σlp
ℓ|graph (4) Πlp
ℓ+1|graph (4),
which by transitivity yields Πlp
ℓ−1|graph (4)⫋Πlp
ℓ|graph (4), and Σlp
ℓ|graph (4)⫋Σlp
ℓ+1|graph (4),
andΠlp
ℓ−1|graph (4)⫋Σlp
ℓ|graph (4)⫋Πlp
ℓ+1|graph (4). This implies the desired inequalities on
arbitrary graphs. ◀
Since the proof of Proposition 35 relies on exhaustive search, it is unlikely to generalize
to arbitrary graphs. This can be restated as follows:
▶Remark 37. The statement of Proposition 35 generalizes to arbitrary graphs if and only if
P=coNP.
Proof.IfP=coNP, then the proof of Proposition 35 does not require the restriction to
graphs of bounded structural degree. Indeed, the local simulations described there can
then be performed by a polynomial-time algorithm that is equivalent to testing all possible
certificate assignments in parallel.
Conversely, if the statement of Proposition 35 holds for arbitrary graphs, then in particular
we have Πlp
0=Πlp
1, which entails Πlp
0|node=Πlp
1|node, and thus P=coNP. ◁
Next, we focus on the relationship between the local-polynomial hierarchy and its com-
plement hierarchy. Using our previous results, it is easy to show that the two hierarchies are
completely distinct.
▶Corollary 38. Classes on the same level of the local-polynomial hierarchy are neither comple-
ment classes of each other, nor are they closed under complementation, even when restricted
to graphs of bounded structural degree. More precisely, Σlp
ℓ|graph (∆)⊈coΠlp
ℓ|graph (∆)ifℓis
odd, and Πlp
ℓ|graph (∆)⊈coΣlp
ℓ|graph (∆)ifℓis even, for all ℓ∈Nand∆≥4. Moreover,
Σlp
ℓ|graph (∆)̸=coΣlp
ℓ|graph (∆)andΠlp
ℓ|graph (∆)̸=coΠlp
ℓ|graph (∆), for allℓ∈Nand∆≥4.
Proof.The statement for ℓ= 0reduces to LP|graph (4)̸=coLP|graph (4), which holds by
Corollary 24.
Forℓ≥1, we first show that none of the classes is closed under complementation,
building on the analogous result for the monadic second-order hierarchy on 0-bit pictures.
By Theorem 27, we know that mΣfo
ℓ|pic(0)andmΠfo
ℓ|pic(0)are incomparable for all ℓ∈N>0.
Since these two classes are complement classes of each other ( FObeing closed under negation),
this means that neither class is closed under complementation. By Theorem 31, this implies
thatΣlfo
ℓ|pic(0)is not closed under complementation if ℓis odd, and that Πlfo
ℓ|pic(0)is not
closed under complementation if ℓis even. We can transfer this result from 0-bit pictures to64 A LOCAL View of the Polynomial Hierarchy
graphs of 4-bounded structural degree by using Lemma 32 in the same way as in the proof of
Theorem 33. This in turn allows us to conclude by Theorem 12 that Σlp
ℓ|graph (4)is not closed
under complementation if ℓis odd, and that Πlp
ℓ|graph (4)is not closed under complementation
ifℓis even. The analogous statement for the remaining cases follows by Proposition 35,
which tells us that Σlp
ℓ|graph (4)=Σlp
ℓ−1|graph (4)ifℓis even, and Πlp
ℓ|graph (4)=Πlp
ℓ−1|graph (4)
ifℓis odd. Hence, we have Σlp
ℓ|graph (4)̸=coΣlp
ℓ|graph (4)andΠlp
ℓ|graph (4)̸=coΠlp
ℓ|graph (4)
for allℓ∈N.
It remains to show for ℓ≥1that the classes on level ℓare not complement classes of each
other. Ifℓis odd, suppose for the sake of contradiction that Σlp
ℓ|graph (4)⊆coΠlp
ℓ|graph (4).
In combination with Proposition 35, this allows us to write the chain of inclusions
Σlp
ℓ|graph (4)⊆coΠlp
ℓ|graph (4)Prp.35=coΠlp
ℓ−1|graph (4)⊆coΣlp
ℓ|graph (4),
which contradicts the already established fact that Σlp
ℓ|graph (4)is not closed under comple-
mentation. Analogously, we can show that Πlp
ℓ|graph (4)⊈coΣlp
ℓ|graph (4)ifℓis even. ◀
Although the local-polynomial hierarchy is distinct from its complement hierarchy, there
are inclusions between the two. This can be shown by generalizing Examples 4 and 5 from
Section 5.2. The strictness of these inclusions is immediate by Corollary 38.
▶Proposition 39. In the local-polynomial hierarchy, complementation can be achieved at
the cost of two or three additional quantifier alternations. More precisely, coΣlp
ℓ⊆Πlp
ℓ+2if
ℓis even, and coΠlp
ℓ⊆Σlp
ℓ+2ifℓis odd, for all ℓ∈N>0.
Proof.Letℓbe even and Lbe a graph property in Σlp
ℓ. By Theorem 12, Lcan be defined
by a Σlfo
ℓ-formula of the form ∃¯R1∀¯R2...∀¯Rℓ∀xψ(x). Based on that, the complement ¯L
can be defined by the formula ∀¯R1∃¯R2...∃¯RℓExistsBadNode , where ExistsBadNode is a
Σlfo
3-formula with free variables in ¯R1,..., ¯Rℓthat is equivalent to ∃x¬ψ(x). The definition
ofExistsBadNode is the same as in Example 5, except that now we use ¬ψ(x)instead
of¬WellColored (x)to instantiate the formula schema PointsTo [ϑ](x). Hence, again by
Theorem 12, ¯L∈Πlp
ℓ+2.
The proof for ℓodd andL∈Πlp
ℓis completely analogous. ◀
▶Corollary 40. The inclusions stated in Proposition 39 are strict, even when restricted to
graphs of bounded structural degree.
Proof.By Corollary 38, we know that Πlp
ℓ|graph (∆)⊈coΣlp
ℓ|graph (∆)for all even ℓ∈N
and∆≥4. This implies that Πlp
ℓ+2|graph (∆)⊈coΣlp
ℓ|graph (∆). Analogously, we obtain
Σlp
ℓ+2|graph (∆)⊈coΠlp
ℓ|graph (∆)for all odd ℓ∈Nand∆≥4. ◀
We end this section by showing that no level of the local-polynomial hierarchy is capable
of expressing graph properties that intuitively require counting the total number of nodes.
To show this, the connection to logic again proves valuable, as it gives us access to classical
results from automata theory.
In the following proposition, we use two examples of counting properties: square denotes
the property of graphs whose cardinality is a perfect square, and primedenotes the property
of graphs whose cardinality is a prime number.
▶Proposition 41. There are graph properties, such as square andprime, that lie outside
the local-polynomial hierarchy, even when restricted to graphs of bounded structural degree.
More precisely, L∩graph (∆)/∈Σlp
ℓ|graph (∆)for allℓ∈Nand∆≥4, whereLcan be
square orprime.F. Reiter 65
Proof sketch. We focus on the statement for prime, as the proof for square is the same.
Assume, for the sake of contradiction, that prime∩graph (4)∈Σlp
ℓ|graph (4)for someℓ∈N,
which we may suppose to be odd without loss of generality. By Theorem 12, this means
there is a Σlfo
ℓ-sentenceφthat defines the graphs of prime cardinality on graph (4). We
can now translate φinto a Σlfo
ℓ-sentenceφ′such that the graph encoding GPof a 0-bit
picturePsatisfiesφ′if and only if the number of pixels of Pis prime. This can be done
similarly to the proof of Lemma 32.1, essentially by relativizing the first-order quantifiers
ofφto “pixel centers” and rewriting the relation ⇀1in terms of the two “ports” through
which adjacent “pixel centers” are connected (see Figure 13). Intuitively, evaluating φ′
onGPcorresponds to evaluating φon the graph obtained from GPby removing all “ports”
and connecting “pixel centers” directly instead. Then, by Lemma 32.2, we can translate φ′
into a Σlfo
ℓ-sentenceφ′′that, when evaluated on pic(0), defines the property prime-grid
of0-bit pictures whose number of pixels is prime. Hence, prime-grid∈Σlfo
ℓ|pic(0), which
by Theorem 31 is equivalent to prime-grid∈mΣfo
ℓ|pic(0). Since the 0-bit picture of size
(1,n)can be identified with the unary word of length n, this means that there is a sentence
of monadic second-order logic defining the language of unary words of prime length. By the
Büchi-Elgot-Trakhtenbrot theorem (see, e.g., [ 38, Thm. 3.1]), we conclude that the same
language is recognized by a finite-state automaton. This, however, is a contradiction because
it can be shown using the pumping lemma for regular languages that no such automaton
exists (see, e.g., [21, §4.1]). ◀
10 Discussion
We have extended the polynomial hierarchy to the localmodel of distributed computing.
Some major results of complexity theory generalize well to this setting, including Fagin’s
theorem and the Cook–Levin theorem. Moreover, we could go beyond what is known in the
centralized setting by showing that the local-polynomial hierarchy is infinite. Descriptive
complexity was very helpful in this regard, as it allowed us to build directly on sophisticated
results from logic and automata theory, in particular the infiniteness of the monadic second-
order hierarchy on pictures.
It seems highly unlikely that this paper will provide new insights into major open problems
in complexity theory, such as Pversus NP. This is because our separation results rely on
the distributed nature of the localmodel. They do not hold in cases where distributedness
is irrelevant, such as on single-node graphs, or when certificates can be replaced by local
computation (see Proposition 35). However, our findings may provide a new perspective on
the concept of locality in distributed computing.
Measuring locality. Within the localmodel, round-time complexity is certainly the most
natural and widely studied measure of locality. It tells us the radius up to which each node
must see in order to solve a given problem. But, as pointed out by Feuilloley [ 8], if we require
the radius to be constant, and compensate for this by introducing nondeterminism, then
certificate size becomes a natural measure of locality. Intuitively, certificate size tells us how
much global information about the graph each node must receive from the prover (Eve) in
order to verify a given property. Now, if we go one step further and additionally restrict
the size of certificates to depend only on a constant-radius neighborhood of the nodes,
and compensate for this in turn by introducing quantifier alternation, then the level of
alternation arguably becomes our new measure of locality. Its meaning is more abstract, as
it represents the number of moves in a two-player game, but the longer the game, the more66 A LOCAL View of the Polynomial Hierarchy
global information the two players can prove or disprove.
Since the local-polynomial hierarchy is infinite, it provides, at least in principle, a fine-
grained measure of locality based on alternation. What remains to be seen is how meaningful
its different levels are, given that the properties used to separate them involve graph encodings
of pictures, which make little sense from a distributed computing perspective. In this paper,
we have seen some initial clues. At the bottom of the hierarchy, the class Πlp
0=LP
represents, by definition, purely local properties. A canonical example of such a property
is Eulerianness, which is LP-complete (by Proposition 15). One level higher, Σlp
1=NLP
represents properties that are almost, but not quite, local. A canonical example of such a
property is 3-colorability, which is NLP-complete (by Theorem 20). Since this property
requires only constant-size certificates to be verified, it can also be considered quasi-local when
using certificate size as the measure of locality. In contrast, the complements of Eulerianness
and3-colorability are more global, as neither of them lies in Σlp
1(by Corollaries 25 and 26).
Wecouldonlyplacenon-Euleriannessin Σlp
3andnon- 3-colorabilityin Πlp
4(byProposition39),
leaving open whether there are matching lower bounds. Perhaps even higher in the hierarchy,
we have Hamiltonicity, which can be viewed as a combination of a quasi-local condition
(having a 2-regular spanning subgraph) and a more global condition (the subgraph must be
connected). Again, we leave open the exact complexity of this property, but we have seen that
it is at most Σlp
5(by Example 6), and strictly greater than Σlp
1(by Corollary 26). In addition,
we have identified some graph properties that lie outside the hierarchy, a fact that indicates
their inherently global nature. We have shown that this is the case for cardinality-dependent
properties, such as the number of nodes being a perfect square or a prime (by Proposition 41),
and we conjecture that the same holds for the property of having a nontrivial automorphism.
To gain a better intuition for the higher levels of the hierarchy, the notions of hardness and
completeness under local-polynomial reductions could be helpful. In the centralized setting,
Meyer and Stockmeyer [ 30] generalized the Cook–Levin theorem to classes of quantified
Boolean formulas, thus providing complete problems for all levels of the polynomial hierarchy
(see, e.g., [ 2, §5.2.2]). Although these problems are rather artificial in themselves, they have
been used to prove the completeness of more natural problems, especially on the second and
third levels of the polynomial hierarchy (see [ 35]). A similar strategy could be pursued in the
distributed setting. It should be straightforward to further generalize our distributed version
of the Cook–Levin theorem (Theorem 19) to cover the entire local-polynomial hierarchy,
and based on that, we may find more natural complete properties for higher levels of the
hierarchy. Given the NLP-completeness of 3-colorability, a promising candidate would be
the generalization of 3-colorability to a family of multi-round games, as introduced by Ajtai,
Fagin, and Stockmeyer [ 1, §11]. While it is to be expected that many graph properties
of interest are not complete for any level of the local-polynomial hierarchy, we may still
be able to derive lower bounds for them by proving their hardness for certain levels of the
hierarchy. For example, although Hamiltonicity is probably not complete for any level of
the local-polynomial hierarchy,4we were still able to show that it does not lie in Σlp
1by
4This is because from the work of Ajtai, Fagin, and Stockmeyer [ 1, §11] we can conclude that each level of
the local-polynomial hierarchy contains a graph property whose string-encoded version is complete for the
corresponding level of the classical polynomial hierarchy. For example, it is easy to see that Πlp
2contains
the property 2-round- 3-colorable , which holds for a given graph Gif every 3-color assignment to
the leaves of Gcan be extended to a valid 3-coloring of G. Thus, if hamiltonian wereΠlp
2-hard, then
by simulating a distributed Turing machine with a centralized one, we could get a polynomial-time
reduction from enc(2-round- 3-colorable )toenc(hamiltonian ), where enc:graph→nodeis some
encoding of graphs as strings. But this would imply the collapse of the polynomial hierarchy to NP,
since enc(2-round- 3-colorable )isΠp
2-complete, and enc(hamiltonian )lies in NP.F. Reiter 67
establishing its coLP-hardness. More generally, just as distributedness made it easier to
separate the different levels of the hierarchy, it can also make it easier to prove unconditional
lower bounds for individual graph properties.
Beyondpolynomialbounds. Astheprimarygoalofthispaperwastoexploretheconnections
between standard complexity theory and local distributed decision, a natural starting point
was to impose polynomial bounds on the processing time and certificate sizes of the nodes.
This allowed us to build on classical results with the help of descriptive complexity and to
take the view that major open questions in standard complexity theory concern a particularly
difficult special case of network computing. However, it could be argued that polynomial
bounds are not the most canonical choice if one wishes to use quantifier alternation purely as
a measure of locality. In that case, the main concern is not to limit the individual processing
power of the nodes, but rather to restrict the certificates in a way that preserves the local
nature of the arbitrating algorithm. As explained in Section 1.3, the three alternation
hierarchies based on LDdo not meet this requirement, since they allow certificate sizes to
depend on the entire input graph.
It turns out that we can generalize the local-polynomial hierarchy without compromising
its potential as a measure of locality, simply by replacing polynomial bounds with arbitrary
bounds. This leads us to define the class LB(forlocal-bounded time ), which consists of all
graph properties that can be decided by a distributed Turing machine operating under locally
unique identifiers and running in constant round time and arbitrary step time (i.e., step time
bounded by some arbitrary computable function). Based on this, we obtain the local-bounded
hierarchy{Σlb
ℓ,Πlb
ℓ}ℓ∈N, which is defined analogously to the local-polynomial hierarchy, but
where the certificate assignments are (r,f)-bounded for some arbitrary computable function
f:N→N.
Most of our results carry over directly to this generalized setting. This includes all of our
separation results, in particular the infiniteness of the hierarchy, since all these separations
already hold on graphs of bounded structural degree, where the local-bounded and the
local-polynomial hierarchies are equivalent. On arbitrary graphs, the local-bounded hierarchy
even exhibits a “cleaner” structure, in the sense that it forms a strict linear order, while
the local-polynomial hierarchy presumably does so only on graphs of bounded structural
degree (see Proposition 35 and Remark 37). Moreover, if we generalize local-polynomial
reductions to reductions computable in constant round time and arbitrary step time, then
all our hardness and completeness results can be extended to the corresponding classes of
the local-bounded hierarchy. This even holds for our distributed version of the Cook–Levin
theorem (Theorem 19), although it would have to be proved directly instead of relying on
descriptive complexity.5Indeed, descriptive complexity is the only aspect of this paper for
which there does not seem to be a direct generalization to the local-bounded hierarchy. This
is quite striking, given that Fagin’s theorem (in its generalized form) has been our guide and
a helpful tool throughout the paper. We used it first as an indicator of the robustness of the
local-polynomial hierarchy, then as a shortcut to easily derive the first completeness result
5A similar observation can be made in the centralized setting: the standard proof of the Cook–Levin
theorem already shows how to construct a Boolean formula that encodes the possible space-time
diagrams of any given nondeterministic Turing machine whose running time is bounded by some
known computable function. While not particularly useful for classical complexity theory, this implies,
for instance, that Boolean satisfiability is NEXPTIME -complete under exponential-time reductions.
(Note, however, that exponential-time reductions are not closed under composition, and that they allow
us to reduce any problem in 2EXPTIME to a problem in EXPTIME .)68 A LOCAL View of the Polynomial Hierarchy
forNLP, and finally as a bridge to the realm of logic and automata theory, where we proved
most of our separation results. In a way, we lose Fagin’s theorem by further generalizing the
hierarchy, but the insights gained from it remain fully applicable.
References
1Miklós Ajtai, Ronald Fagin, and Larry J. Stockmeyer. The closure of monadic NP. J. Comput.
Syst. Sci. , 60(3):660–716, 2000. doi:10.1006/jcss.1999.1691 .
2Sanjeev Arora and Boaz Barak. Computational Complexity - A Modern Approach . Cambridge
University Press, 2009. URL: http://www.cambridge.org/catalogue/catalogue.asp?isbn=
9780521424264 .
3Alkida Balliu, Gianlorenzo D’Angelo, Pierre Fraigniaud, and Dennis Olivetti. What can be
verified locally? J. Comput. Syst. Sci. , 97:106–120, 2018. doi:10.1016/j.jcss.2018.05.004 .
4Benedikt Bollig, Patricia Bouyer, and Fabian Reiter. Identifiers in registers - describing network
algorithmswithlogic. InMikolajBojanczykandAlexSimpson, editors, Foundations of Software
Science and Computation Structures - 22nd International Conference, FOSSACS 2019, Held
as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2019,
Prague, Czech Republic, April 6-11, 2019, Proceedings , volume 11425 of Lecture Notes in
Computer Science , pages 115–132. Springer, 2019. doi:10.1007/978-3-030-17127-8\_7 .
5Stephen A. Cook. The complexity of theorem-proving procedures. In Michael A. Harrison,
Ranan B. Banerji, and Jeffrey D. Ullman, editors, Proceedings of the 3rd Annual ACM
Symposium on Theory of Computing, May 3-5, 1971, Shaker Heights, Ohio, USA , pages
151–158. ACM, 1971. doi:10.1145/800157.805047 .
6Reinhard Diestel. Graph Theory, 5th Edition , volume 173 of Graduate texts in math-
ematics. Springer, 2017. URL: http://diestel-graph-theory.com ,doi:10.1007/
978-3-662-53622-3 .
7Ronald Fagin. Generalized first-order spectra and polynomial-time recognizable sets. In
Richard M. Karp, editor, Complexity of Computation , volume 7 of SIAM-AMS Proceedings ,
pages 43–73, 1974.
8Laurent Feuilloley. Introduction to local certification. Discret. Math. Theor. Comput. Sci. ,
23(3), 2021. doi:10.46298/dmtcs.6280 .
9Laurent Feuilloley and Pierre Fraigniaud. Survey of distributed decision. Bulletin of the
EATCS, 119, 2016. URL: http://eatcs.org/beatcs/index.php/beatcs/article/view/411 .
10Laurent Feuilloley, Pierre Fraigniaud, and Juho Hirvonen. A hierarchy of local decision. Theor.
Comput. Sci. , 856:51–67, 2021. doi:10.1016/j.tcs.2020.12.017 .
11Laurent Feuilloley and Juho Hirvonen. Local verification of global proofs. In Ulrich Schmid and
Josef Widder, editors, 32nd International Symposium on Distributed Computing, DISC 2018,
New Orleans, LA, USA, October 15-19, 2018 , volume 121 of LIPIcs, pages 25:1–25:17. Schloss
Dagstuhl - Leibniz-Zentrum für Informatik, 2018. doi:10.4230/LIPIcs.DISC.2018.25 .
12Pierre Fraigniaud. Distributed computational complexities: are you volvo-addicted or nascar-
obsessed? In Andréa W. Richa and Rachid Guerraoui, editors, Proceedings of the 29th Annual
ACM Symposium on Principles of Distributed Computing, PODC 2010, Zurich, Switzerland,
July 25-28, 2010 , pages 171–172. ACM, 2010. doi:10.1145/1835698.1835700 .
13Pierre Fraigniaud, Magnús M. Halldórsson, and Amos Korman. On the impact of identifiers on
local decision. In Roberto Baldoni, Paola Flocchini, and Binoy Ravindran, editors, Principles
of Distributed Systems, 16th International Conference, OPODIS 2012, Rome, Italy, December
18-20, 2012. Proceedings , volume 7702 of Lecture Notes in Computer Science , pages 224–238.
Springer, 2012. doi:10.1007/978-3-642-35476-2\_16 .
14Pierre Fraigniaud, Amos Korman, and David Peleg. Towards a complexity theory for local
distributed computing. J. ACM, 60(5):35:1–35:26, 2013. doi:10.1145/2499228 .
15Dora Giammarresi and Antonio Restivo. Recognizable picture languages. IJPRAI, 6(2&3):241–
256, 1992. doi:10.1142/S021800149200014X .F. Reiter 69
16Dora Giammarresi, Antonio Restivo, Sebastian Seibert, and Wolfgang Thomas. Monadic
second-order logic over rectangular pictures and recognizability by tiling systems. Inf. Comput. ,
125(1):32–45, 1996. doi:10.1006/inco.1996.0018 .
17Oded Goldreich. Computational Complexity - A Conceptual Perspective . Cambridge University
Press, 2008. doi:10.1017/CBO9780511804106 .
18Mika Göös and Jukka Suomela. Locally checkable proofs in distributed computing. Theory
Comput., 12(1):1–33, 2016. doi:10.4086/toc.2016.v012a019 .
19ErichGrädel, PhokionG.Kolaitis, LeonidLibkin, MaartenMarx, JoelSpencer, MosheY.Vardi,
Yde Venema, and Scott Weinstein. Finite Model Theory and Its Applications . Texts in Theo-
retical Computer Science. An EATCS Series. Springer, 2007. doi:10.1007/3-540-68804-8 .
20Lauri Hella, Matti Järvisalo, Antti Kuusisto, Juhana Laurinharju, Tuomo Lempiäinen,
Kerkko Luosto, Jukka Suomela, and Jonni Virtema. Weak models of distributed com-
puting, with connections to modal logic. Distributed Comput. , 28(1):31–53, 2015. doi:
10.1007/s00446-013-0202-3 .
21John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman. Introduction to automata theory,
languages, and computation, 3rd Edition . Pearson international edition. Addison-Wesley, 2007.
22Richard M. Karp. Reducibility among combinatorial problems. In Raymond E. Miller and
James W. Thatcher, editors, Proceedings of a symposium on the Complexity of Computer
Computations, held March 20-22, 1972, at the IBM Thomas J. Watson Research Center,
Yorktown Heights, New York, USA , The IBM Research Symposia Series, pages 85–103. Plenum
Press, New York, 1972. doi:10.1007/978-1-4684-2001-2\_9 .
23Amos Korman, Shay Kutten, and David Peleg. Proof labeling schemes. Distributed Comput. ,
22(4):215–233, 2010. doi:10.1007/s00446-010-0095-3 .
24AnttiKuusisto. Modallogicanddistributedmessagepassingautomata. InSimonaRonchiDella
Rocca, editor, Computer Science Logic 2013 (CSL 2013), CSL 2013, September 2-5, 2013,
Torino, Italy , volume 23 of LIPIcs, pages 452–468. Schloss Dagstuhl - Leibniz-Zentrum für
Informatik, 2013. doi:10.4230/LIPIcs.CSL.2013.452 .
25Leonid A. Levin. Universal sequential search problems (in Russian). Problemy Peredachi
Informatsii , 9(3):115–116, 1973. URL: http://mi.mathnet.ru/ppi914 .
26Leonid Libkin. Elements of Finite Model Theory . Texts in Theoretical Computer Science.
An EATCS Series. Springer, 2004. URL: http://www.cs.toronto.edu/%7Elibkin/fmt ,doi:
10.1007/978-3-662-07003-1 .
27Nathan Linial. Locality in distributed graph algorithms. SIAM J. Comput. , 21(1):193–201,
1992. doi:10.1137/0221015 .
28Oliver Matz. Dot-depth, monadic quantifier alternation, and first-order closure over grids and
pictures. Theor. Comput. Sci. , 270(1-2):1–70, 2002. doi:10.1016/S0304-3975(01)00277-8 .
29Oliver Matz, Nicole Schweikardt, and Wolfgang Thomas. The monadic quantifier alternation
hierarchy over grids and graphs. Inf. Comput. , 179(2):356–383, 2002. doi:10.1006/inco.
2002.2955 .
30Albert R. Meyer and Larry J. Stockmeyer. The equivalence problem for regular expressions
with squaring requires exponential space. In 13th Annual Symposium on Switching and
Automata Theory, College Park, Maryland, USA, October 25-27, 1972 , pages 125–129. IEEE
Computer Society, 1972. doi:10.1109/SWAT.1972.29 .
31Moni Naor and Larry J. Stockmeyer. What can be computed locally? SIAM J. Comput. ,
24(6):1259–1277, 1995. doi:10.1137/S0097539793254571 .
32Christos H. Papadimitriou. Computational complexity . Addison-Wesley, 1994.
33David Peleg. Distributed Computing: A Locality-Sensitive Approach , volume 5 of SIAM
Monographs on Discrete Mathematics and Applications . Society for Industrial and Applied
Mathematics (SIAM), 2000. doi:10.1137/1.9780898719772 .
34Fabian Reiter. Asynchronous distributed automata: A characterization of the modal mu-
fragment. In Ioannis Chatzigiannakis, Piotr Indyk, Fabian Kuhn, and Anca Muscholl, editors,
44th International Colloquium on Automata, Languages, and Programming, ICALP 2017, July70 A LOCAL View of the Polynomial Hierarchy
10-14, 2017, Warsaw, Poland , volume 80 of LIPIcs, pages 100:1–100:14. Schloss Dagstuhl -
Leibniz-Zentrum für Informatik, 2017. doi:10.4230/LIPIcs.ICALP.2017.100 .
35Marcus Schaefer and Christopher Umans. Completeness in the polynomial time hierarchy - A
compendium. SIGACT News, Complexity Theory Column , 33(3/4):32–49/22–36, 2002. URL:
https://ovid.cs.depaul.edu/documents/phcom.pdf ,doi:10.1145/582475.582484 .
36Larry J. Stockmeyer. The polynomial-time hierarchy. Theor. Comput. Sci. , 3(1):1–22, 1976.
doi:10.1016/0304-3975(76)90061-X .
37Jukka Suomela. Landscape of locality (invited talk). In Susanne Albers, editor, 17th Scan-
dinavian Symposium and Workshops on Algorithm Theory, SWAT 2020, June 22-24, 2020,
Tórshavn, Faroe Islands , volume 162 of LIPIcs, pages 2:1–2:1. Schloss Dagstuhl - Leibniz-
Zentrum für Informatik, 2020. URL: https://jukkasuomela.fi/landscape-of-locality ,
doi:10.4230/LIPIcs.SWAT.2020.2 .
38Wolfgang Thomas. Languages, automata, and logic. In Grzegorz Rozenberg and Arto Salomaa,
editors,Handbook of Formal Languages, Volume 3: Beyond Words , pages 389–455. Springer,
1997. doi:10.1007/978-3-642-59126-6\_7 .
39Eden Aldema Tshuva and Rotem Oshman. Brief announcement: On polynomial-time local
decision. In Alessia Milani and Philipp Woelfel, editors, PODC ’22: ACM Symposium on
Principles of Distributed Computing, Salerno, Italy, July 25 - 29, 2022 , pages 48–50. ACM,
2022. doi:10.1145/3519270.3538463 .